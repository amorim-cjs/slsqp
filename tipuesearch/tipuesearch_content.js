var tipuesearch = {"pages":[{"title":" slsqp ","text":"slsqp SLSQP Modern Fortran Edition of the SLSQP Optimizer Status Description This is an updated version of the SLSQP nonlinear constrained optimization code. It can be used to solve nonlinear programming problems that seek to minimize a scalar performance index subject to nonlinear equality and inequality constraints as well as bounds on the variables. Updates to the original code include: It has been translated into free-form source. It is now thread safe. The original version was not thread safe due to the use of saved variables in one of the subroutines. It no longer uses obsolescent and non-standard Fortran features. It should now be 100% standard compliant (Fortran 2008). It now has an easy-to-use object-oriented interface. The slsqp_class is used for all interactions with the solver. Methods include initialize() , optimize() , and destroy() . It includes updated versions of some of the third-party routines used in the original code (BLAS, LINPACK, and NNLS). Some new features were added to support printing error  messages and reporting iterations to the user. The user can now specify the max and min alpha to use during the line search. The user can supply a routine to compute the gradients of the objective function and constriants, or allow the code to estimate them using finite differences (backward, forward, or central). The documentation strings in the code have been converted to FORD format, allowing for nicely formatted documentation to be auto-generated. A couple of bug fixes noted elsewhere have been applied. License The original sourcecode and the modifications are released under a permissive BSD-style license . Building SLSQP A FoBiS configuration file ( slsqp.fobis ) is also provided that can also build the library and examples. Use the mode flag to indicate what to build. For example: To build all the examples using gfortran: FoBiS.py build -f slsqp.fobis -mode tests-gnu To build all the examples using ifort: FoBiS.py build -f slsqp.fobis -mode tests-intel To build a static library using gfortran: FoBiS.py build -f slsqp.fobis -mode static-gnu To build a static library using ifort: FoBiS.py build -f slsqp.fobis -mode static-intel The full set of modes are: static-gnu , static-gnu-debug , static-intel , static-intel-debug , shared-gnu , shared-gnu-debug , shared-intel , shared-intel-debug , tests-gnu , tests-gnu-debug , tests-intel , tests-intel-debug To generate the documentation using ford , run: FoBis.py rule --execute makedoc -f slsqp.fobis To run the test programs, run: FoBis.py rule --execute tests -f slsqp.fobis Development Development continues on GitHub . Documentation The latest API documentation can be found here . This was generated from the source code using FORD (note that the included build.sh script will also generate these files). References Original sourcecode at NETLIB D. Kraft, \" A software package for sequential quadratic programming \",\n  Technical Report DFVLR-FB 88-28, Institut für Dynamik der Flugsysteme,\n  Oberpfaffenhofen, July 1988. D. Kraft, \" Algorithm 733: TOMP--Fortran modules for optimal control calculations ,\"\n  ACM Transactions on Mathematical Software, Vol. 20, No. 3, p. 262-281 (1994). Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"slsqp_support.f90 – slsqp","text":"This file depends on sourcefile~~slsqp_support.f90~~EfferentGraph sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~slsqp_support.f90~~AfferentGraph sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_support.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules slsqp_support Source Code slsqp_support.f90 Source Code !******************************************************************************* !> license: BSD ! !  Support routines for SLSQP. For example, routines from !  [BLAS](http://www.netlib.org/blas/) and [LINPACK](http://www.netlib.org/linpack/). !  These have also been refactored into modern Fortran. module slsqp_support use slsqp_kinds implicit none private real ( wp ), parameter , public :: epmach = epsilon ( 1.0_wp ) real ( wp ), parameter , public :: zero = 0.0_wp real ( wp ), parameter , public :: one = 1.0_wp real ( wp ), parameter , public :: two = 2.0_wp real ( wp ), parameter , public :: four = 4.0_wp real ( wp ), parameter , public :: ten = 1 0.0_wp real ( wp ), parameter , public :: hun = 10 0.0_wp public :: daxpy , dcopy , ddot , dnrm2 , dscal contains !******************************************************************************* !******************************************************************************* !> !  constant times a vector plus a vector. !  uses unrolled loops for increments equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. subroutine daxpy ( n , da , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) , da integer :: i , incx , incy , ix , iy , m , mp1 , n if ( n <= 0 ) return if ( abs ( da ) <= zero ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 4 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dy ( i ) + da * dx ( i ) end do if ( n < 4 ) return end if mp1 = m + 1 do i = mp1 , n , 4 dy ( i ) = dy ( i ) + da * dx ( i ) dy ( i + 1 ) = dy ( i + 1 ) + da * dx ( i + 1 ) dy ( i + 2 ) = dy ( i + 2 ) + da * dx ( i + 2 ) dy ( i + 3 ) = dy ( i + 3 ) + da * dx ( i + 3 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dy ( iy ) + da * dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine daxpy !******************************************************************************* !******************************************************************************* !> !  copies a vector, x, to a vector, y. !  uses unrolled loops for increments equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. subroutine dcopy ( n , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) integer :: i , incx , incy , ix , iy , m , mp1 , n if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 7 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dx ( i ) end do if ( n < 7 ) return end if mp1 = m + 1 do i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine dcopy !******************************************************************************* !******************************************************************************* !> !  forms the dot product of two vectors. !  uses unrolled loops for increments equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. real ( wp ) function ddot ( n , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) , dtemp integer :: i , incx , incy , ix , iy , m , mp1 , n ddot = zero dtemp = zero if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) end do if ( n < 5 ) then ddot = dtemp return end if end if mp1 = m + 1 do i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + & dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) end do ddot = dtemp else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy end do ddot = dtemp end if end function ddot !******************************************************************************* !******************************************************************************* !> !  Function that returns the Euclidean norm !   \\sqrt{ \\mathbf{x}&#94;T \\mathbf{x} }  of a vector  \\mathbf{x} . ! !### Further details ! !  * this version written on 25-october-1982. !  * modified on 14-october-1993 to inline the call to dlassq. !    sven hammarling, nag ltd. !  * Converted to modern Fortran, Jacob Williams, Jan. 2016. ! !@note Replaced original SLSQP routine with this one from !      [BLAS](http://netlib.sandia.gov/blas/dnrm2.f). real ( wp ) function dnrm2 ( n , x , incx ) implicit none integer , intent ( in ) :: incx integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ) :: absxi , norm , scale , ssq integer :: ix if ( n < 1 . or . incx < 1 ) then norm = zero elseif ( n == 1 ) then norm = abs ( x ( 1 )) else scale = zero ssq = one ! the following loop is equivalent to this call to the lapack ! auxiliary routine: ! call dlassq( n, x, incx, scale, ssq ) do ix = 1 , 1 + ( n - 1 ) * incx , incx if ( abs ( x ( ix )) > zero ) then absxi = abs ( x ( ix )) if ( scale < absxi ) then ssq = one + ssq * ( scale / absxi ) ** 2 scale = absxi else ssq = ssq + ( absxi / scale ) ** 2 end if end if end do norm = scale * sqrt ( ssq ) end if dnrm2 = norm end function dnrm2 !******************************************************************************* !******************************************************************************* !> !  scales a vector by a constant. !  uses unrolled loops for increment equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. subroutine dscal ( n , da , dx , incx ) implicit none real ( wp ) :: da , dx ( * ) integer :: i , incx , m , mp1 , n , nincx if ( n <= 0 . or . incx <= 0 ) return if ( incx == 1 ) then ! code for increment equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dx ( i ) = da * dx ( i ) end do if ( n < 5 ) return end if mp1 = m + 1 do i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) end do else ! code for increment not equal to 1 nincx = n * incx do i = 1 , nincx , incx dx ( i ) = da * dx ( i ) end do end if end subroutine dscal !******************************************************************************* !******************************************************************************* end module slsqp_support !*******************************************************************************","tags":"","loc":"sourcefile/slsqp_support.f90.html"},{"title":"slsqp_module.f90 – slsqp","text":"This file depends on sourcefile~~slsqp_module.f90~~EfferentGraph sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules slsqp_module Source Code slsqp_module.f90 Source Code !******************************************************************************* !> author: Jacob Williams !  license: BSD ! !  Module containing the object-oriented interface to the SLSQP method. !  It is called using the [[slsqp_solver]] class, which !  is the only public entity in this module. module slsqp_module use slsqp_kinds use slsqp_support use slsqp_core use iso_fortran_env , only : error_unit , output_unit implicit none private type , public :: slsqp_solver !! The main class used to interface with the SLSQP solver. private integer :: n = 0 !! number of optimization variables ( n > 0 ) integer :: m = 0 !! number of constraints ( m \\ge 0 ) integer :: meq = 0 !! number of equality constraints ( m \\ge m_{eq} \\ge 0 ) integer :: max_iter = 0 !! maximum number of iterations real ( wp ) :: acc = zero !! accuracy tolerance real ( wp ) :: tolf = - one !! accuracy tolerance over f:  if  |f| < tolf  then stop real ( wp ) :: toldf = - one !! accuracy tolerance over df: if  |f_{n+1} - f_n| < toldf  then stop. !! It's different from `acc` in the case of positive derivative real ( wp ) :: toldx = - one !! accuracy tolerance over xf: if  |x_{n+1} - x_n| < toldx  then stop integer :: gradient_mode = 0 !! how the gradients are computed: !! !! * 0 - use the user-supplied `g` subroutine. [default] !! * 1 - approximate by basic backward differences !! * 2 - approximate by basic forward differences !! * 3 - approximate by basic central differences real ( wp ) :: gradient_delta = 1.0e8_wp !! perturbation step size to approximate gradients !! by finite differences (`gradient_mode` 1-3). !these two were not in the original code: real ( wp ) :: alphamin = 0.1_wp !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ) :: alphamax = 1.0_wp !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: iprint = output_unit !! unit number of status printing (0 for no printing) real ( wp ), dimension (:), allocatable :: xl !! lower bound on x real ( wp ), dimension (:), allocatable :: xu !! upper bound on x integer :: l_w = 0 !! size of `w` real ( wp ), dimension (:), allocatable :: w !! real work array procedure ( func ), pointer :: f => null () !! problem function subroutine procedure ( grad ), pointer :: g => null () !! gradient subroutine procedure ( iterfunc ), pointer :: report => null () !! for reporting an iteration integer :: linesearch_mode = 1 !! linesearch mode: !! !! * `1` = inexact (Armijo) linesearch, !! * `2` = exact linesearch. type ( linmin_data ) :: linmin !! data formerly within [[linmin]]. !! Only used when `linesearch_mode=2` type ( slsqpb_data ) :: slsqpb !! data formerly within [[slsqpb]]. logical :: user_triggered_stop = . false . !! if the `abort` method has been called !! to stop the iterations contains private procedure , public :: initialize => initialize_slsqp procedure , public :: destroy => destroy_slsqp procedure , public :: optimize => slsqp_wrapper procedure , public :: abort => stop_iterations procedure :: report_message !! for reporting messages to the user end type slsqp_solver abstract interface subroutine func ( me , x , f , c ) !! for computing the function import :: wp , slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( out ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. end subroutine func subroutine grad ( me , x , g , a ) !! for computing the gradients import :: wp , slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( out ) :: g !! objective function partials w.r.t x `dimension(n)` real ( wp ), dimension (:,:), intent ( out ) :: a !! gradient matrix of constraints w.r.t. x `dimension(m,n)` end subroutine grad subroutine iterfunc ( me , iter , x , f , c ) !! for reporting an iteration import :: wp , slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: iter !! iteration number real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( in ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( in ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. end subroutine iterfunc end interface contains !******************************************************************************* !******************************************************************************* !> !  A method that the user can call to stop the iterations. !  (it can be called in any of the functions). !  SLSQP will stop at the end of the next iteration. subroutine stop_iterations ( me ) implicit none class ( slsqp_solver ), intent ( inout ) :: me me % user_triggered_stop = . true . end subroutine stop_iterations !******************************************************************************* !******************************************************************************* !> !  initialize the [[slsqp_solver]] class.  see [[slsqp]] for more details. subroutine initialize_slsqp ( me , n , m , meq , max_iter , acc , f , g , xl , xu , status_ok ,& linesearch_mode , iprint , report , alphamin , alphamax ,& gradient_mode , gradient_delta , tolf , toldf , toldx ) implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: n !! the number of variables,  n \\ge 1  integer , intent ( in ) :: m !! total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: max_iter !! maximum number of iterations procedure ( func ) :: f !! problem function procedure ( grad ) :: g !! function to compute gradients (must be !! associated if `gradient_mode=0`) real ( wp ), dimension ( n ), intent ( in ) :: xl !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xu !! upper bounds on `x` real ( wp ), intent ( in ) :: acc !! accuracy logical , intent ( out ) :: status_ok !! will be false if there were errors integer , intent ( in ), optional :: linesearch_mode !! 1 = inexact (default), 2 = exact integer , intent ( in ), optional :: iprint !! unit number of status messages (default=output_unit) procedure ( iterfunc ), optional :: report !! user-defined procedure that will be called once per iteration real ( wp ), intent ( in ), optional :: alphamin !! minimum alpha for linesearch [default 0.1] real ( wp ), intent ( in ), optional :: alphamax !! maximum alpha for linesearch [default 1.0] integer , intent ( in ), optional :: gradient_mode !! how the gradients are to be computed: !! !! * 0 - use the user-supplied `g` subroutine. [default] !! * 1 - approximate by basic backward differences !! * 2 - approximate by basic forward differences !! * 3 - approximate by basic central differences real ( wp ), intent ( in ), optional :: gradient_delta !! perturbation step size (>epsilon) to compute the approximated !! gradient by finite differences (`gradient_mode` 1-3). !! note that this is an absolute step that does not respect !! the `xl` or `xu` variable bounds. real ( wp ), intent ( in ), optional :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ), optional :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop real ( wp ), intent ( in ), optional :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop integer :: n1 , mineq , i status_ok = . false . call me % destroy () if ( present ( iprint )) me % iprint = iprint if ( size ( xl ) /= size ( xu ) . or . size ( xl ) /= n ) then call me % report_message ( 'error: invalid upper or lower bound vector size' ) call me % report_message ( '  size(xl) =' , ival = size ( xl )) call me % report_message ( '  size(xu) =' , ival = size ( xu )) call me % report_message ( '  n        =' , ival = n ) else if ( meq < 0 . or . meq > m ) then call me % report_message ( 'error: invalid meq value:' , ival = meq ) else if ( m < 0 ) then call me % report_message ( 'error: invalid m value:' , ival = m ) else if ( n < 1 ) then call me % report_message ( 'error: invalid n value:' , ival = n ) else if ( any ( xl > xu )) then call me % report_message ( 'error: lower bounds must be <= upper bounds.' ) do i = 1 , n if ( xl ( i ) > xu ( i )) then call me % report_message ( '  xl(i)>xu(i) for variable' , ival = i ) end if end do else if ( present ( linesearch_mode )) then !two linesearch modes: select case ( linesearch_mode ) case ( 1 ) !inexact me % linesearch_mode = linesearch_mode case ( 2 ) !exact me % linesearch_mode = linesearch_mode case default call me % report_message ( 'error: invalid linesearch_mode (must be 1 or 2): ' ,& ival = linesearch_mode ) call me % destroy () return end select end if !optional linesearch bounds: if ( present ( alphamin )) me % alphamin = alphamin if ( present ( alphamax )) me % alphamax = alphamax !verify valid values for alphamin and alphamax: 0<alphamin<alphamax<=1 if ( me % alphamin <= zero . or . me % alphamax <= zero . or . & me % alphamax <= me % alphamin . or . & me % alphamin >= one . or . me % alphamax > one ) then call me % report_message ( 'error: invalid values for alphamin or alphamax.' ) call me % report_message ( '  alphamin =' , rval = me % alphamin ) call me % report_message ( '  alphamax =' , rval = me % alphamax ) call me % destroy () return end if if ( present ( tolf )) me % tolf = tolf if ( present ( toldf )) me % toldf = toldf if ( present ( toldx )) me % toldx = toldx status_ok = . true . me % n = n me % m = m me % meq = meq me % max_iter = max_iter me % acc = acc me % f => f me % g => g if ( present ( report )) me % report => report allocate ( me % xl ( n )); me % xl = xl allocate ( me % xu ( n )); me % xu = xu !work arrays: n1 = n + 1 mineq = m - meq + 2 * n1 me % l_w = n1 * ( n1 + 1 ) + meq * ( n1 + 1 ) + mineq * ( n1 + 1 ) + & !for lsq ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + & !for lsi ( n1 + mineq ) * ( n1 - meq ) + 2 * meq + n1 + & !for lsei n1 * n / 2 + 2 * m + 3 * n + 3 * n1 + 1 !for slsqpb allocate ( me % w ( me % l_w )) me % w = zero if ( present ( gradient_mode )) then me % gradient_mode = gradient_mode if ( present ( gradient_delta )) then me % gradient_delta = gradient_delta end if end if end if end subroutine initialize_slsqp !******************************************************************************* !******************************************************************************* !> !  destructor for [[slsqp_solver]]. subroutine destroy_slsqp ( me ) implicit none class ( slsqp_solver ), intent ( out ) :: me end subroutine destroy_slsqp !******************************************************************************* !******************************************************************************* !> !  main routine for calling [[slsqp]]. subroutine slsqp_wrapper ( me , x , istat , iterations , status_message ) implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x !! **in:**  initial optimization variables, !! **out:** solution. integer , intent ( out ) :: istat !! status code (see `mode` in [[slsqp]]). integer , intent ( out ), optional :: iterations !! number of iterations character ( len = :), intent ( out ), allocatable , optional :: status_message !! string status message !! corresponding to `istat` ! local variables: real ( wp ), dimension (:), allocatable :: c !! constraint vector -- `dimension(max(1,me%m))` real ( wp ), dimension (:,:), allocatable :: a !! a matrix for [[slsqp]] -- `dimension(max(1,me%m),me%n+1)` real ( wp ), dimension (:), allocatable :: g !! g matrix for [[slsqp]] -- `dimension(me%n+1)` real ( wp ), dimension (:), allocatable :: cvec !! constraint vector -- `dimension(me%m)` real ( wp ), dimension (:), allocatable :: dfdx !! objective function partials -- `dimension(me%n)` real ( wp ), dimension (:,:), allocatable :: dcdx !! constraint partials -- `dimension(me%m,me%n)` real ( wp ), dimension (:), allocatable :: delta !! perturbation step size to approximate gradient -- `dimension(me%n)` real ( wp ), dimension (:), allocatable :: cvecr !! right function value to approximate constraints vector's gradient -- `dimension(me%m)` real ( wp ), dimension (:), allocatable :: cvecl !! left function value to approximate constraints vector's gradient -- `dimension(me%m)` real ( wp ) :: f !! objective function integer :: i !! iteration counter integer :: mode !! reverse communication flag for [[slsqp]] integer :: la !! input to [[slsqp]] integer :: iter !! in/out for [[slsqp]] real ( wp ) :: acc !! in/out for [[slsqp]] integer :: ig !! loop index to approximate gradient real ( wp ) :: fr !! right function value to approximate objective function's gradient real ( wp ) :: fl !! left function value to approximate objective function's gradient real ( wp ) :: fact !! denominator factor for finite difference approximation !initialize: allocate ( c ( max ( 1 , me % m )) ) allocate ( a ( max ( 1 , me % m ), me % n + 1 )) allocate ( g ( me % n + 1 ) ) allocate ( cvec ( me % m ) ) allocate ( dfdx ( me % n ) ) allocate ( dcdx ( me % m , me % n ) ) allocate ( delta ( me % n ) ) allocate ( cvecr ( me % m ) ) allocate ( cvecl ( me % m ) ) i = 0 iter = me % max_iter la = max ( 1 , me % m ) mode = 0 a = zero g = zero c = zero if ( present ( iterations )) iterations = 0 call me % linmin % destroy () call me % slsqpb % destroy () !check setup: if ( size ( x ) /= me % n ) then istat = - 100 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !linesearch: select case ( me % linesearch_mode ) case ( 1 ) !inexact (armijo-type linesearch) acc = abs ( me % acc ) case ( 2 ) !exact acc = - abs ( me % acc ) case default istat = - 101 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end select !make sure the functions have been associated: if (. not . associated ( me % f )) then istat = - 102 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if (( me % gradient_mode == 0 ). and .(. not . associated ( me % g ))) then istat = - 103 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if ( me % gradient_mode < 0 . or . me % gradient_mode > 3 ) then istat = - 104 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if ( me % gradient_mode /= 0 . and . me % gradient_delta <= epmach ) then istat = - 105 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !main solver loop: do if ( mode == 0 . or . mode == 1 ) then !function evaluation (f&c) call me % f ( x , f , cvec ) c ( 1 : me % m ) = cvec end if if ( mode == 0 . or . mode ==- 1 ) then !gradient evaluation (g&a) select case ( me % gradient_mode ) case ( 0 ) ! user supplied gradients call me % g ( x , dfdx , dcdx ) g ( 1 : me % n ) = dfdx a ( 1 : me % m , 1 : me % n ) = dcdx case default ! approximate using finite differences if ( me % gradient_mode == 3 ) then fact = two ! central differences else fact = one ! forward/backward differences end if do ig = 1 , me % n !initialize a delta to perturb the objective !function and the constraint vector delta = zero delta ( ig ) = me % gradient_delta !get the right and left value of the objective !function and the constraint vector select case ( me % gradient_mode ) case ( 1 ) ! backward difference call me % f ( x , fr , cvecr ) call me % f ( x - delta , fl , cvecl ) case ( 2 ) ! forward difference call me % f ( x + delta , fr , cvecr ) call me % f ( x , fl , cvecl ) case ( 3 ) ! central difference call me % f ( x + delta , fr , cvecr ) call me % f ( x - delta , fl , cvecl ) end select !compute the gradients by first-order finite differences g ( ig ) = ( fr - fl ) / ( fact * delta ( ig ) ) if ( me % m > 0 ) then a (:, ig ) = ( cvecr - cvecl ) / ( fact * delta ( ig ) ) end if end do end select !this is an iteration: !note: the initial guess is reported as iteration 0: if ( associated ( me % report )) call me % report ( i , x , f , c ) !report iteration i = i + 1 ! iteration counter end if !main routine: call slsqp ( me % m , me % meq , la , me % n , x , me % xl , me % xu ,& f , c , g , a , acc , iter , mode ,& me % w , me % l_w ,& me % slsqpb , me % linmin , me % alphamin , me % alphamax ,& me % tolf , me % toldf , me % toldx ) if ( mode == 1 . or . mode ==- 1 ) then !continue to next call else if ( mode == 0 . and . associated ( me % report )) & call me % report ( i , x , f , c ) !report solution call me % report_message ( mode_to_status_message ( mode )) exit end if if ( me % user_triggered_stop ) then mode = - 2 call me % report_message ( mode_to_status_message ( mode )) me % user_triggered_stop = . false . !have to reset in case !method is called again. exit end if end do istat = mode if ( present ( iterations )) iterations = iter if ( present ( status_message )) status_message = mode_to_status_message ( istat ) end subroutine slsqp_wrapper !******************************************************************************* !******************************************************************************* !> !  Report a message from an [[slsqp_solver]] class. This uses the `iprint` !  variable in the class as the unit number for printing. Note: for fatal errors, !  if no unit is specified, the `error_unit` is used. subroutine report_message ( me , str , ival , rval , fatal ) implicit none class ( slsqp_solver ), intent ( in ) :: me character ( len =* ), intent ( in ) :: str !! the message to report. integer , intent ( in ), optional :: ival !! optional integer to print after the message. real ( wp ), intent ( in ), optional :: rval !! optional real to print after the message. logical , intent ( in ), optional :: fatal !! if True, then the program is stopped (default=False). logical :: stop_program !! true if the program is to be stopped logical :: write_message !! true if the message is to be printed character ( len = 10 ) :: istr !! string version of `ival` character ( len = 30 ) :: rstr !! string version of `rval` character ( len = :), allocatable :: str_to_write !! the actual message to the printed integer :: istat !! iostat for integer to string conversion !fatal error check: if ( present ( fatal )) then stop_program = fatal else stop_program = . false . end if !note: if stopping program, then the message is always printed: write_message = me % iprint /= 0 . or . stop_program if ( write_message ) then if ( present ( ival )) then write ( istr , fmt = '(I10)' , iostat = istat ) ival if ( istat /= 0 ) istr = '*****' str_to_write = str // ' ' // trim ( adjustl ( istr )) elseif ( present ( rval )) then write ( istr , fmt = '(F30.16)' , iostat = istat ) rval if ( istat /= 0 ) rstr = '*****' str_to_write = str // ' ' // trim ( adjustl ( rstr )) else str_to_write = str end if if ( me % iprint == 0 ) then write ( error_unit , '(A)' ) str_to_write !in this case, use the error unit else write ( me % iprint , '(A)' ) str_to_write !user specified unit number end if deallocate ( str_to_write ) if ( stop_program ) error stop 'Fatal Error' end if end subroutine report_message !******************************************************************************* !******************************************************************************* !> !  Convert the [[slsqp]] `mode` flag to a message string. pure function mode_to_status_message ( imode ) result ( message ) implicit none integer , intent ( in ) :: imode character ( len = :), allocatable :: message select case ( imode ) case ( 0 ) !required accuracy for solution obtained message = 'Required accuracy for solution obtained' case ( - 100 ) message = 'Invalid size(x) in slsqp_wrapper' case ( - 101 ) message = 'Invalid linesearch_mode in slsqp_wrapper' case ( - 102 ) message = 'Function is not associated' case ( - 103 ) message = 'Gradient function is not associated' case ( - 104 ) message = 'Invalid gradient mode' case ( - 105 ) message = 'Invalid perturbation step size for finite difference gradients' case ( - 2 ) message = 'User-triggered stop of slsqp' case ( 1 , - 1 ) message = 'In progress' case ( 2 ) message = 'Number of equality constraints larger than n' case ( 3 ) message = 'More than 3*n iterations in lsq subproblem' case ( 4 ) message = 'Inequality constraints incompatible' case ( 5 ) message = 'Singular matrix e in lsq subproblem' case ( 6 ) message = 'Singular matrix c in lsq subproblem' case ( 7 ) message = 'Rank-deficient equality constraint subproblem hfti' case ( 8 ) message = 'Positive directional derivative for linesearch' case ( 9 ) message = 'More than max_iter iterations in slsqp' case default message = 'Unknown slsqp error' end select end function mode_to_status_message !******************************************************************************* !******************************************************************************* end module slsqp_module !*******************************************************************************","tags":"","loc":"sourcefile/slsqp_module.f90.html"},{"title":"slsqp_kinds.f90 – slsqp","text":"Files dependent on this one sourcefile~~slsqp_kinds.f90~~AfferentGraph sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_support.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules slsqp_kinds Source Code slsqp_kinds.f90 Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 12/22/2015 !  license: BSD ! !  Numeric kind definitions. module slsqp_kinds use , intrinsic :: iso_fortran_env , only : real64 implicit none private integer , parameter , public :: wp = real64 !! Using \"double precision\" real kinds end module slsqp_kinds !*****************************************************************************************","tags":"","loc":"sourcefile/slsqp_kinds.f90.html"},{"title":"slsqp_core.f90 – slsqp","text":"This file depends on sourcefile~~slsqp_core.f90~~EfferentGraph sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~slsqp_core.f90~~AfferentGraph sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_core.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules slsqp_core Source Code slsqp_core.f90 Source Code !******************************************************************************* !> license: BSD ! !  Core subroutines for the SLSQP optimization method. !  These are refactoried versions of the original routines. module slsqp_core use slsqp_kinds use slsqp_support implicit none private type , public :: linmin_data !! data formerly saved in [[linmin]] routine. real ( wp ) :: a = zero real ( wp ) :: b = zero real ( wp ) :: d = zero real ( wp ) :: e = zero real ( wp ) :: p = zero real ( wp ) :: q = zero real ( wp ) :: r = zero real ( wp ) :: u = zero real ( wp ) :: v = zero real ( wp ) :: w = zero real ( wp ) :: x = zero real ( wp ) :: m = zero real ( wp ) :: fu = zero real ( wp ) :: fv = zero real ( wp ) :: fw = zero real ( wp ) :: fx = zero real ( wp ) :: tol1 = zero real ( wp ) :: tol2 = zero contains procedure :: destroy => destroy_linmin_data end type linmin_data type , public :: slsqpb_data !! data formerly saved in [[slsqpb]]. real ( wp ) :: t = zero real ( wp ) :: f0 = zero real ( wp ) :: h1 = zero real ( wp ) :: h2 = zero real ( wp ) :: h3 = zero real ( wp ) :: h4 = zero real ( wp ) :: t0 = zero real ( wp ) :: gs = zero real ( wp ) :: tol = zero real ( wp ) :: alpha = zero integer :: line = 0 integer :: iexact = 0 integer :: incons = 0 integer :: ireset = 0 integer :: itermx = 0 integer :: n1 = 0 integer :: n2 = 0 integer :: n3 = 0 contains procedure :: destroy => destroy_slsqpb_data end type slsqpb_data public :: slsqp contains !******************************************************************************* !******************************************************************************* !> !  **slsqp**: **s**equential **l**east **sq**uares **p**rogramming !  to solve general nonlinear optimization problems ! !  a nonlinear programming method with quadratic programming subproblems !  this subroutine solves the general nonlinear programming problem: ! !  **minimize** ! !  *  f(x)  ! !  **subject to** ! !  *  c_j (x) = 0 ,            j = 1,...,meq    !  *  c_j (x) \\ge 0 ,          j = meq+1,...,m  !  *  xl_i \\le x_i \\le xu_i ,  i = 1,...,n      ! !  the algorithm implements the method of Han and Powell !  with BFGS-update of the b-matrix and L1-test function !  within the steplength algorithm. ! !### Reference !   * Dieter Kraft: \"A software package for sequential quadratic programming\", !     DFVLR-FB 88-28, 1988 ! !### History !   * implemented by: Dieter Kraft, DFVLR oberpfaffenhofen !   * date: april - october, 1981. !   * December, 31-st, 1984. !   * March   , 21-st, 1987, revised to fortran 77 !   * March   , 20-th, 1989, revised to ms-fortran !   * April   , 14-th, 1989, hesse   in-line coded !   * February, 28-th, 1991, fortran/2 version 1.04 accepts statement functions !   * March   ,  1-st, 1991, tested with salford ftn77/386 compiler vers 2.40 in protected mode !   * January ,        2016, Refactored into modern Fortran by Jacob Williams ! !### License !  Original version copyright 1991: Dieter Kraft, FHM. !  Released under a BSD license. ! !@note `f`, `c`, `g`, `a` must all be set by the user before each call. subroutine slsqp ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode , w , l_w , & sdat , ldat , alphamin , alphamax , tolf , toldf , toldx ) implicit none integer , intent ( in ) :: m !! is the total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! is the number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: la !! see `a`,  la \\ge \\max(m,1)  integer , intent ( in ) :: n !! is the number of variables,  n \\ge 1  real ( wp ), dimension ( n ), intent ( inout ) :: x !! `x()` stores the current iterate of the `n` vector `x` !! on entry `x()` must be initialized. on exit `x()` !! stores the solution vector `x` if `mode = 0`. real ( wp ), dimension ( n ), intent ( in ) :: xl !! `xl()` stores an n vector of lower bounds `xl` to `x`. real ( wp ), dimension ( n ), intent ( in ) :: xu !! `xu()` stores an n vector of upper bounds `xu` to `x`. real ( wp ), intent ( in ) :: f !! is the value of the objective function. real ( wp ), dimension ( la ), intent ( in ) :: c !! `c()` stores the `m` vector `c` of constraints, !! equality constraints (if any) first. !! dimension of `c` must be greater or equal `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), dimension ( n + 1 ), intent ( in ) :: g !! `g()` stores the `n` vector `g` of partials of the !! objective function; dimension of `g` must be !! greater or equal `n+1`. real ( wp ), dimension ( la , n + 1 ), intent ( in ) :: a !! the `la` by `n + 1` array `a()` stores !! the `m` by `n` matrix `a` of constraint normals. !! `a()` has first dimensioning parameter `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), intent ( inout ) :: acc !! `abs(acc)` controls the final accuracy. !! if `acc` < zero an exact linesearch is performed, !! otherwise an armijo-type linesearch is used. integer , intent ( inout ) :: iter !! prescribes the maximum number of iterations. !! on exit `iter` indicates the number of iterations. integer , intent ( inout ) :: mode !! mode controls calculation: !! !! reverse communication is used in the sense that !! the program is initialized by `mode = 0`; then it is !! to be called repeatedly by the user until a return !! with `mode /= abs(1)` takes place. !! if `mode = -1` gradients have to be calculated, !! while with `mode = 1` functions have to be calculated. !! mode must not be changed between subsequent calls of [[slsqp]]. !! !! **evaluation modes**: !! !! * ** -1 **: gradient evaluation, (`g` & `a`) !! * **  0 **: *on entry*: initialization, (`f`, `g`, `c`, `a`), !!   *on exit*: required accuracy for solution obtained !! * **  1 **: function evaluation, (`f` & `c`) !! !! **failure modes**: !! !! * ** 2 **: number of equality constraints larger than `n` !! * ** 3 **: more than `3*n` iterations in [[lsq]] subproblem !! * ** 4 **: inequality constraints incompatible !! * ** 5 **: singular matrix `e` in [[lsq]] subproblem !! * ** 6 **: singular matrix `c` in [[lsq]] subproblem !! * ** 7 **: rank-deficient equality constraint subproblem [[hfti]] !! * ** 8 **: positive directional derivative for linesearch !! * ** 9 **: more than `iter` iterations in sqp !! * ** >=10 **: working space `w` too small, !!   `w` should be enlarged to `l_w=mode/1000`, integer , intent ( in ) :: l_w !! the length of `w`, which should be at least: !! !! * `(3*n1+m)*(n1+1)`                     **for lsq** !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`     **for lsi** !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`   **for lsei** !! * `+ n1*n/2 + 2*m + 3*n + 3*n1 + 1`     **for slsqpb** !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` real ( wp ), dimension ( l_w ), intent ( inout ) :: w !! `w()` is a one dimensional working space. !! the first `m+n+n*n1/2` elements of `w` must not be !! changed between subsequent calls of [[slsqp]]. !! on return `w(1) ... w(m)` contain the multipliers !! associated with the general constraints, while !! `w(m+1) ... w(m+n(n+1)/2)` store the cholesky factor !! `l*d*l(t)` of the approximate hessian of the !! lagrangian columnwise dense as lower triangular !! unit matrix `l` with `d` in its 'diagonal' and !! `w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n)` !! contain the multipliers associated with all !! constraints of the quadratic program finding !! the search direction to the solution `x*` type ( slsqpb_data ), intent ( inout ) :: sdat !! data for [[slsqpb]]. type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ) :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop. real ( wp ), intent ( in ) :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop. integer :: il , im , ir , is , iu , iv , iw , ix , mineq , n1 !   check length of working arrays n1 = n + 1 mineq = m - meq + n1 + n1 il = ( 3 * n1 + m ) * ( n1 + 1 ) + ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + ( n1 + mineq )& * ( n1 - meq ) + 2 * meq + n1 * n / 2 + 2 * m + 3 * n + 4 * n1 + 1 im = max ( mineq , n1 - meq ) if ( l_w < il ) then mode = 1000 * max ( 10 , il ) mode = mode + max ( 10 , im ) iter = 0 return end if if ( meq > n ) then ! note: calling lsq when meq>n is corrupting the ! memory in some way, so just catch this here. mode = 2 iter = 0 return end if !   prepare data for calling sqpbdy  -  initial addresses in w im = 1 il = im + max ( 1 , m ) il = im + la ix = il + n1 * n / 2 + 1 ir = ix + n is = ir + n + n + max ( 1 , m ) is = ir + n + n + la iu = is + n1 iv = iu + n1 iw = iv + n1 sdat % n1 = n1 call slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& w ( ir ), w ( il ), w ( ix ), w ( im ), w ( is ), w ( iu ), w ( iv ), w ( iw ),& sdat % t , sdat % f0 , sdat % h1 , sdat % h2 , sdat % h3 , sdat % h4 ,& sdat % n1 , sdat % n2 , sdat % n3 , sdat % t0 , sdat % gs , sdat % tol , sdat % line ,& sdat % alpha , sdat % iexact , sdat % incons , sdat % ireset , sdat % itermx ,& ldat , alphamin , alphamax , tolf , toldf , toldx ) end subroutine slsqp !******************************************************************************* !******************************************************************************* !> !  nonlinear programming by solving sequentially quadratic programs ! !  l1 - line search, positive definite bfgs update subroutine slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& r , l , x0 , mu , s , u , v , w ,& t , f0 , h1 , h2 , h3 , h4 , n1 , n2 , n3 , t0 , gs , tol , line ,& alpha , iexact , incons , ireset , itermx , ldat ,& alphamin , alphamax , tolf , toldf , toldx ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: meq integer , intent ( in ) :: la integer , intent ( in ) :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: f real ( wp ), dimension ( la ) :: c real ( wp ), dimension ( n + 1 ) :: g real ( wp ), dimension ( la , n + 1 ) :: a real ( wp ) :: acc integer , intent ( inout ) :: iter !! **in:**  maximum number of iterations. !! **out:** actual number of iterations. integer , intent ( inout ) :: mode real ( wp ), dimension ( m + n + n + 2 ) :: r real ( wp ), dimension (( n + 1 ) * ( n + 2 ) / 2 ) :: l real ( wp ), dimension ( n ) :: x0 real ( wp ), dimension ( la ) :: mu real ( wp ), dimension ( n + 1 ) :: s real ( wp ), dimension ( n + 1 ) :: u real ( wp ), dimension ( n + 1 ) :: v real ( wp ), dimension ( * ), intent ( inout ) :: w !! `dim(w)` = !! !! * `n1*(n1+1) + meq*(n1+1) + mineq*(n1+1)`   for [[lsq]] !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`         for [[lsi]] !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`       for [[lsei]] !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` real ( wp ), intent ( inout ) :: t real ( wp ), intent ( inout ) :: f0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( inout ) :: h2 real ( wp ), intent ( inout ) :: h3 real ( wp ), intent ( inout ) :: h4 integer , intent ( inout ) :: n1 integer , intent ( inout ) :: n2 integer , intent ( inout ) :: n3 real ( wp ), intent ( inout ) :: t0 real ( wp ), intent ( inout ) :: gs real ( wp ), intent ( inout ) :: tol integer , intent ( inout ) :: line real ( wp ), intent ( inout ) :: alpha integer , intent ( inout ) :: iexact integer , intent ( inout ) :: incons integer , intent ( inout ) :: ireset integer , intent ( inout ) :: itermx type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ) :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop real ( wp ), intent ( in ) :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop integer :: i , j , k if ( mode < 0 ) then ! call jacobian at current x ! update cholesky-factors of hessian matrix by modified bfgs formula do i = 1 , n u ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) - v ( i ) end do ! l'*s k = 0 do i = 1 , n h1 = zero k = k + 1 do j = i + 1 , n k = k + 1 h1 = h1 + l ( k ) * s ( j ) end do v ( i ) = s ( i ) + h1 end do ! d*l'*s k = 1 do i = 1 , n v ( i ) = l ( k ) * v ( i ) k = k + n1 - i end do ! l*d*l'*s do i = n , 1 , - 1 h1 = zero k = i do j = 1 , i - 1 h1 = h1 + l ( k ) * v ( j ) k = k + n - j end do v ( i ) = v ( i ) + h1 end do h1 = ddot ( n , s , 1 , u , 1 ) h2 = ddot ( n , s , 1 , v , 1 ) h3 = 0.2_wp * h2 if ( h1 < h3 ) then h4 = ( h2 - h3 ) / ( h2 - h1 ) h1 = h3 call dscal ( n , h4 , u , 1 ) call daxpy ( n , one - h4 , v , 1 , u , 1 ) end if call ldl ( n , l , u , + one / h1 , v ) call ldl ( n , l , v , - one / h2 , u ) ! end of main iteration goto 200 else if ( mode == 0 ) then itermx = iter if ( acc >= zero ) then iexact = 0 else iexact = 1 end if acc = abs ( acc ) tol = ten * acc iter = 0 ireset = 0 n1 = n + 1 n2 = n1 * n / 2 n3 = n2 + 1 s ( 1 ) = zero mu ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) call dcopy ( m , mu ( 1 ), 0 , mu , 1 ) else ! call functions at current x t = f do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if t = t + mu ( j ) * max ( - c ( j ), h1 ) end do h1 = t - t0 if ( iexact + 1 == 1 ) then if ( h1 <= h3 / ten . or . line > 10 ) goto 500 alpha = min ( max ( h3 / ( two * ( h3 - h1 )), alphamin ), alphamax ) goto 300 else if ( iexact + 1 == 2 ) then goto 400 else goto 500 end if end if ! reset bfgs matrix 100 ireset = ireset + 1 if ( ireset > 5 ) then ! check relaxed convergence in case of positive directional derivative mode = check_convergence ( n , f , f0 , x , x0 , s , h3 , tol , tolf , toldf , toldx , 0 , 8 ) return else l ( 1 ) = zero call dcopy ( n2 , l ( 1 ), 0 , l , 1 ) j = 1 do i = 1 , n l ( j ) = one j = j + n1 - i end do end if ! main iteration : search direction, steplength, ldl'-update 200 iter = iter + 1 mode = 9 if ( iter > itermx ) return ! search direction as solution of qp - subproblem call dcopy ( n , xl , 1 , u , 1 ) call dcopy ( n , xu , 1 , v , 1 ) call daxpy ( n , - one , x , 1 , u , 1 ) call daxpy ( n , - one , x , 1 , v , 1 ) h4 = one call lsq ( m , meq , n , n3 , la , l , g , a , c , u , v , s , r , w , mode ) ! augmented problem for inconsistent linearization if ( mode == 6 ) then if ( n == meq ) mode = 4 end if if ( mode == 4 ) then do j = 1 , m if ( j <= meq ) then a ( j , n1 ) = - c ( j ) else a ( j , n1 ) = max ( - c ( j ), zero ) end if end do s ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) h3 = zero g ( n1 ) = zero l ( n3 ) = hun s ( n1 ) = one u ( n1 ) = zero v ( n1 ) = one incons = 0 250 call lsq ( m , meq , n1 , n3 , la , l , g , a , c , u , v , s , r , w , mode ) h4 = one - s ( n1 ) if ( mode == 4 ) then l ( n3 ) = ten * l ( n3 ) incons = incons + 1 if ( incons <= 5 ) goto 250 return else if ( mode /= 1 ) then return end if else if ( mode /= 1 ) then return end if ! update multipliers for l1-test do i = 1 , n v ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) end do f0 = f call dcopy ( n , x , 1 , x0 , 1 ) gs = ddot ( n , g , 1 , s , 1 ) h1 = abs ( gs ) h2 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h2 = h2 + max ( - c ( j ), h3 ) h3 = abs ( r ( j )) mu ( j ) = max ( h3 ,( mu ( j ) + h3 ) / two ) h1 = h1 + h3 * abs ( c ( j )) end do ! check convergence mode = 0 if ( h1 < acc . and . h2 < acc ) return h1 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h1 = h1 + mu ( j ) * max ( - c ( j ), h3 ) end do t0 = f + h1 h3 = gs - h1 * h4 mode = 8 if ( h3 >= zero ) goto 100 ! line search with an l1-testfunction line = 0 alpha = alphamax if ( iexact == 1 ) goto 400 ! inexact linesearch 300 line = line + 1 h3 = alpha * h3 call dscal ( n , alpha , s , 1 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , one , s , 1 , x , 1 ) call enforce_bounds ( x , xl , xu ) ! ensure that x doesn't violate bounds mode = 1 return ! exact linesearch 400 if ( line /= 3 ) then alpha = linmin ( line , alphamin , alphamax , t , tol , & ldat % a , ldat % b , ldat % d , ldat % e , ldat % p , ldat % q , & ldat % r , ldat % u , ldat % v , ldat % w , ldat % x , ldat % m , & ldat % fu , ldat % fv , ldat % fw , ldat % fx , ldat % tol1 , ldat % tol2 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , alpha , s , 1 , x , 1 ) mode = 1 return end if call dscal ( n , alpha , s , 1 ) ! check convergence 500 h3 = zero do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if h3 = h3 + max ( - c ( j ), h1 ) end do mode = check_convergence ( n , f , f0 , x , x0 , s , h3 , acc , tolf , toldf , toldx , 0 , - 1 ) end subroutine slsqpb !******************************************************************************* !******************************************************************************* !> !  Check for convergence. function check_convergence ( n , f , f0 , x , x0 , s , h3 , acc , tolf , toldf , toldx ,& converged , not_converged ) result ( mode ) implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: f real ( wp ), intent ( in ) :: f0 real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: x0 real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), intent ( in ) :: h3 real ( wp ), intent ( in ) :: acc real ( wp ), intent ( in ) :: tolf real ( wp ), intent ( in ) :: toldf real ( wp ), intent ( in ) :: toldx integer , intent ( in ) :: converged !! mode value if converged integer , intent ( in ) :: not_converged !! mode value if not converged integer :: mode logical :: ok ! temp variable real ( wp ), dimension ( n ) :: xmx0 if ( h3 < acc ) then mode = not_converged else ! if any are OK then it is converged ok = . false . if (. not . ok ) ok = abs ( f - f0 ) < acc if (. not . ok ) ok = dnrm2 ( n , s , 1 ) < acc ! note that these can be ignored if they are < 0: if (. not . ok . and . tolf >= zero ) ok = abs ( f ) < tolf if (. not . ok . and . toldf >= zero ) ok = abs ( f - f0 ) < toldf if (. not . ok . and . toldx >= zero ) then xmx0 = x - x0 ! to avoid array temporary warning ok = dnrm2 ( n , xmx0 , 1 ) < toldx end if if ( ok ) then mode = converged else mode = not_converged end if end if end function check_convergence !******************************************************************************* !******************************************************************************* !> !  Minimize  || e x - f ||  with respect to x, !  with upper triangular matrix  e = + d &#94;{1/2} l&#94;T , !  and vector  f = -d&#94;{-1/2} l&#94;{-1} g , !  where the unit lower tridiangular matrix l is stored columnwise !  dense in the n*(n+1)/2 array l with vector d stored in its !  'diagonal' thus substituting the one-elements of l ! !  subject to: ! !  *  a(j)*x - b(j) = 0,              j=1,...,meq  , !  *  a(j)*x - b(j) \\ge 0,            j=meq+1,...,m, !  *  x_l(i) \\le x(i) \\le x_u(i),     i=1,...,n    , ! !  On entry, the user has to provide the arrays `l`, `g`, `a`, `b`, `xl`, `xu`. !  with dimensions: `l(n*(n+1)/2)`, `g(n)`, `a(la,n)`, `b(m)`, `xl(n)`, `xu(n)`. ! !  The working array `w` must have at least the following dimension: dim(w) = ! !  * `(3*n+m)*(n+1)`                    for [[lsq]] !  * `+(n-meq+1)*(mineq+2) + 2*mineq`   for [[lsi]] !  * `+(n+mineq)*(n-meq) + 2*meq + n`   for [[lsei]] ! !  with `mineq = m - meq + 2*n` ! !  On return, no array will be changed by the subroutine. ! !### History !  * coded dieter kraft, april 1987 !  * revised march 1989 subroutine lsq ( m , meq , n , nl , la , l , g , a , b , xl , xu , x , y , w , mode ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: meq integer , intent ( in ) :: nl integer , intent ( in ) :: la real ( wp ), dimension ( n ) :: x !! stores the n-dimensional solution vector real ( wp ), dimension ( m + n + n ) :: y !! stores the vector of lagrange multipliers of dimension !! m+n+n (constraints+lower+upper bounds) integer :: mode !! is a success-failure flag with the following meanings: !! !! * **1:** successful computation, !! * **2:** error return because of wrong dimensions (`n<1`), !! * **3:** iteration count exceeded by [[nnls]], !! * **4:** inequality constraints incompatible, !! * **5:** matrix `e` is not of full rank, !! * **6:** matrix `c` is not of full rank, !! * **7:** rank defect in [[hfti]] real ( wp ), dimension ( nl ) :: l real ( wp ), dimension ( n ) :: g real ( wp ), dimension ( la , n ) :: a real ( wp ), dimension ( la ) :: b real ( wp ), dimension ( * ) :: w real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: diag , xnorm integer :: i , ic , id , ie , if , ig , ih , il , im , ip , & iu , iw , i1 , i2 , i3 , i4 , mineq , & m1 , n1 , n2 , n3 n1 = n + 1 mineq = m - meq m1 = mineq + n + n !  determine whether to solve problem !  with inconsistent linerarization (n2=1) !  or not (n2=0) n2 = n1 * n / 2 + 1 if ( n2 == nl ) then n2 = 0 else n2 = 1 end if n3 = n - n2 !  recover matrix e and vector f from l and g i2 = 1 i3 = 1 i4 = 1 ie = 1 if = n * n + 1 do i = 1 , n3 i1 = n1 - i diag = sqrt ( l ( i2 )) w ( i3 ) = zero call dcopy ( i1 , w ( i3 ), 0 , w ( i3 ), 1 ) call dcopy ( i1 - n2 , l ( i2 ), 1 , w ( i3 ), n ) call dscal ( i1 - n2 , diag , w ( i3 ), n ) w ( i3 ) = diag w ( if - 1 + i ) = ( g ( i ) - ddot ( i - 1 , w ( i4 ), 1 , w ( if ), 1 )) / diag i2 = i2 + i1 - n2 i3 = i3 + n1 i4 = i4 + n end do if ( n2 == 1 ) then w ( i3 ) = l ( nl ) w ( i4 ) = zero call dcopy ( n3 , w ( i4 ), 0 , w ( i4 ), 1 ) w ( if - 1 + n ) = zero end if call dscal ( n , - one , w ( if ), 1 ) ic = if + n id = ic + meq * n if ( meq > 0 ) then !  recover matrix c from upper part of a do i = 1 , meq call dcopy ( n , a ( i , 1 ), la , w ( ic - 1 + i ), meq ) end do !  recover vector d from upper part of b call dcopy ( meq , b ( 1 ), 1 , w ( id ), 1 ) call dscal ( meq , - one , w ( id ), 1 ) end if ig = id + meq if ( mineq > 0 ) then !  recover matrix g from lower part of a do i = 1 , mineq call dcopy ( n , a ( meq + i , 1 ), la , w ( ig - 1 + i ), m1 ) end do end if !  augment matrix g by +i and -i ip = ig + mineq do i = 1 , n w ( ip - 1 + i ) = zero call dcopy ( n , w ( ip - 1 + i ), 0 , w ( ip - 1 + i ), m1 ) end do w ( ip ) = one call dcopy ( n , w ( ip ), 0 , w ( ip ), m1 + 1 ) im = ip + n do i = 1 , n w ( im - 1 + i ) = zero call dcopy ( n , w ( im - 1 + i ), 0 , w ( im - 1 + i ), m1 ) end do w ( im ) = - one call dcopy ( n , w ( im ), 0 , w ( im ), m1 + 1 ) ih = ig + m1 * n if ( mineq > 0 ) then ! recover h from lower part of b call dcopy ( mineq , b ( meq + 1 ), 1 , w ( ih ), 1 ) call dscal ( mineq , - one , w ( ih ), 1 ) end if !  augment vector h by xl and xu il = ih + mineq call dcopy ( n , xl , 1 , w ( il ), 1 ) iu = il + n call dcopy ( n , xu , 1 , w ( iu ), 1 ) call dscal ( n , - one , w ( iu ), 1 ) iw = iu + n call lsei ( w ( ic ), w ( id ), w ( ie ), w ( if ), w ( ig ), w ( ih ), max ( 1 , meq ), meq , n , n , & m1 , m1 , n , x , xnorm , w ( iw ), mode ) if ( mode == 1 ) then ! restore lagrange multipliers call dcopy ( m , w ( iw ), 1 , y ( 1 ), 1 ) call dcopy ( n3 , w ( iw + m ), 1 , y ( m + 1 ), 1 ) call dcopy ( n3 , w ( iw + m + n ), 1 , y ( m + n3 + 1 ), 1 ) call enforce_bounds ( x , xl , xu ) ! to ensure that bounds are not violated end if end subroutine lsq !******************************************************************************* !******************************************************************************* !> !  for `mode=1`, the subroutine returns the solution `x` of !  equality & inequality constrained least squares problem lsei : ! !   \\underset{x}{\\min} ||E x - f||  ! !  s.t.   C x  = d   and  G x \\ge h . ! !  using QR decomposition & orthogonal basis of nullspace of  C . ! !  The following dimensions of the arrays defining the problem !  are necessary: !```` !        dim(c) :   formal (lc,n),    actual (mc,n) !        dim(d) :   formal (lc  ),    actual (mc  ) !        dim(e) :   formal (le,n),    actual (me,n) !        dim(f) :   formal (le  ),    actual (me  ) !        dim(g) :   formal (lg,n),    actual (mg,n) !        dim(h) :   formal (lg  ),    actual (mg  ) !        dim(x) :   formal (n   ),    actual (n   ) !        dim(w) :   2*mc+me+(me+mg)*(n-mc)  for lsei !                 +(n-mc+1)*(mg+2)+2*mg     for lsi !        dim(jw):   max(mg,l) !```` ! !  On entry, the user has to provide the arrays C, d, E, f, G, and h. !  On return, all arrays will be changed by the subroutine. ! !### Reference !  * Chapter 23.6 of Lawson & Hanson: Solving least squares problems. ! !### History !  * 18.5.1981, dieter kraft, dfvlr oberpfaffenhofen !  * 20.3.1987, dieter kraft, dfvlr oberpfaffenhofen subroutine lsei ( c , d , e , f , g , h , lc , mc , le , me , lg , mg , n , x , xnrm , w , mode ) implicit none integer , intent ( in ) :: lc integer , intent ( in ) :: mc integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( lc , n ), intent ( inout ) :: c real ( wp ), dimension ( lc ) , intent ( inout ) :: d real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnrm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! on return, stores the vector of lagrange multipliers !! in its first `mc+mg` elements integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank, !! * ***6:*** matrix `c` is not of full rank, !! * ***7:*** rank defect in [[hfti]] integer :: i , ie , if , ig , iw , j , k , krank , l , mc1 real ( wp ) :: t , dum ( 1 ) mode = 2 if ( mc <= n ) then l = n - mc mc1 = mc + 1 iw = ( l + 1 ) * ( mg + 2 ) + 2 * mg + mc ie = iw + mc + 1 if = ie + me * l ig = if + me !  triangularize c and apply factors to e and g do i = 1 , mc j = min ( i + 1 , lc ) call h12 ( 1 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), c ( j , 1 ), lc , 1 , mc - i ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), e , le , 1 , me ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), g , lg , 1 , mg ) end do !  solve c*x=d and modify f mode = 6 do i = 1 , mc if ( abs ( c ( i , i )) < epmach ) return x ( i ) = ( d ( i ) - ddot ( i - 1 , c ( i , 1 ), lc , x , 1 )) / c ( i , i ) end do mode = 1 w ( mc1 ) = zero !call dcopy(mg-mc,w(mc1),0,w(mc1),1)  ! original code call dcopy ( mg , w ( mc1 ), 0 , w ( mc1 ), 1 ) ! bug fix for when meq = n if ( mc /= n ) then do i = 1 , me w ( if - 1 + i ) = f ( i ) - ddot ( mc , e ( i , 1 ), le , x , 1 ) end do !  store transformed e & g do i = 1 , me call dcopy ( l , e ( i , mc1 ), le , w ( ie - 1 + i ), me ) end do do i = 1 , mg call dcopy ( l , g ( i , mc1 ), lg , w ( ig - 1 + i ), mg ) end do if ( mg > 0 ) then !  modify h and solve inequality constrained ls problem do i = 1 , mg h ( i ) = h ( i ) - ddot ( mc , g ( i , 1 ), lg , x , 1 ) end do call lsi ( w ( ie ), w ( if ), w ( ig ), h , me , me , mg , mg , l , x ( mc1 ), xnrm , & w ( mc1 ), mode ) if ( mc == 0 ) return t = dnrm2 ( mc , x , 1 ) xnrm = sqrt ( xnrm * xnrm + t * t ) if ( mode /= 1 ) return else ! solve ls without inequality constraints mode = 7 k = max ( le , n ) t = sqrt ( epmach ) call hfti ( w ( ie ), me , me , l , w ( if ), k , 1 , t , krank , dum , w , w ( l + 1 )) xnrm = dum ( 1 ) call dcopy ( l , w ( if ), 1 , x ( mc1 ), 1 ) if ( krank /= l ) return mode = 1 end if end if !  solution of original problem and lagrange multipliers do i = 1 , me f ( i ) = ddot ( n , e ( i , 1 ), le , x , 1 ) - f ( i ) end do do i = 1 , mc d ( i ) = ddot ( me , e ( 1 , i ), 1 , f , 1 ) & - ddot ( mg , g ( 1 , i ), 1 , w ( mc1 ), 1 ) end do do i = mc , 1 , - 1 call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), x , 1 , 1 , 1 ) end do do i = mc , 1 , - 1 j = min ( i + 1 , lc ) w ( i ) = ( d ( i ) - ddot ( mc - i , c ( j , i ), 1 , w ( j ), 1 )) / c ( i , i ) end do end if end subroutine lsei !******************************************************************************* !******************************************************************************* !> !  for `mode=1`, the subroutine returns the solution `x` of !  inequality constrained linear least squares problem: ! !   \\underset{x}{\\min} ||E x - f||  ! !  s.t.  G x \\ge h . ! !  the following dimensions of the arrays defining the problem !  are necessary: !```` !     dim(e) :   formal (le,n),    actual (me,n) !     dim(f) :   formal (le  ),    actual (me  ) !     dim(g) :   formal (lg,n),    actual (mg,n) !     dim(h) :   formal (lg  ),    actual (mg  ) !     dim(x) :   n !     dim(w) :   (n+1)*(mg+2) + 2*mg !     dim(jw):   lg !```` ! !  on entry, the user has to provide the arrays `e`, `f`, `g`, and `h`. !  on return, all arrays will be changed by the subroutine. ! !### Reference !  * Chapter 23.6 of Lawson & Hanson: Solving least squares problems. ! !### History !  * 03.01.1980, dieter kraft: coded !  * 20.03.1987, dieter kraft: revised to fortran 77 subroutine lsi ( e , f , g , h , le , me , lg , mg , n , x , xnorm , w , mode ) implicit none integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnorm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! stores the vector of lagrange multipliers in its first !! `mg` elements integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank. integer :: i , j real ( wp ) :: t !  qr-factors of e and application to f do i = 1 , n j = min ( i + 1 , n ) call h12 ( 1 , i , i + 1 , me , e ( 1 , i ), 1 , t , e ( 1 , j ), 1 , le , n - i ) call h12 ( 2 , i , i + 1 , me , e ( 1 , i ), 1 , t , f , 1 , 1 , 1 ) end do !  transform g and h to get least distance problem mode = 5 do i = 1 , mg do j = 1 , n if ( abs ( e ( j , j )) < epmach ) return g ( i , j ) = ( g ( i , j ) - ddot ( j - 1 , g ( i , 1 ), lg , e ( 1 , j ), 1 )) / e ( j , j ) end do h ( i ) = h ( i ) - ddot ( n , g ( i , 1 ), lg , f , 1 ) end do !  solve least distance problem call ldp ( g , lg , mg , n , h , x , xnorm , w , mode ) if ( mode == 1 ) then !  solution of original problem call daxpy ( n , one , f , 1 , x , 1 ) do i = n , 1 , - 1 j = min ( i + 1 , n ) x ( i ) = ( x ( i ) - ddot ( n - i , e ( i , j ), le , x ( j ), 1 )) / e ( i , i ) end do j = min ( n + 1 , me ) t = dnrm2 ( me - n , f ( j ), 1 ) xnorm = sqrt ( xnorm * xnorm + t * t ) end if end subroutine lsi !******************************************************************************* !******************************************************************************* !> !  Least distance programming routine. !  Minimize  \\frac{1}{2} \\mathbf{x}&#94;T \\mathbf{x}   subject to !   \\mathbf{G} \\mathbf{x} \\ge \\mathbf{h} . ! !  The declared dimension of `w` must be at least `(n+1)*(m+2)+2*m`: !```` !       first (n+1)*m locs of w = matrix e for problem nnls. !       next      n+1 locs of w = vector f for problem nnls. !       next      n+1 locs of w = vector z for problem nnls. !       next        m locs of w = vector y for problem nnls. !       next        m locs of w = vector wdual for problem nnls. !```` ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. ! !@note The 1995 version of this routine may have some sort of problem. !      Using a refactored version of the original routine. subroutine ldp ( g , mg , m , n , h , x , xnorm , w , mode ) implicit none integer , intent ( in ) :: mg integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), dimension ( mg , n ), intent ( in ) :: g !! on entry `g` stores the `m` by `n` matrix of !! linear inequality constraints. `g` has first !! dimensioning parameter `mg` real ( wp ), dimension ( m ), intent ( in ) :: h !! the right side of the inequality system. real ( wp ), dimension ( n ), intent ( out ) :: x !! solution vector `x` if `mode=1`. real ( wp ), dimension ( * ), intent ( inout ) :: w !! `w` is a one dimensional working space, the length !! of which should be at least `(m+2)*(n+1) + 2*m`. !! on exit `w` stores the lagrange multipliers !! associated with the constraints. !! at the solution of problem `ldp`. real ( wp ), intent ( out ) :: xnorm !! euclidian norm of the solution vector !! if computation is successful integer , intent ( out ) :: mode !! success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<=0`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible. integer :: i , iw , iwdual , iy , iz , j , jf , n1 real ( wp ) :: fac , rnorm if ( n <= 0 ) then ! error return. mode = 2 else ! state dual problem mode = 1 x = zero xnorm = zero if ( m /= 0 ) then iw = 0 do j = 1 , m do i = 1 , n iw = iw + 1 w ( iw ) = g ( j , i ) end do iw = iw + 1 w ( iw ) = h ( j ) end do jf = iw + 1 do i = 1 , n iw = iw + 1 w ( iw ) = zero end do w ( iw + 1 ) = one n1 = n + 1 iz = iw + 2 iy = iz + n1 iwdual = iy + m ! solve dual problem call nnls ( w , n1 , n1 , m , w ( jf ), w ( iy ), rnorm , w ( iwdual ), w ( iz ), mode ) if ( mode == 1 ) then mode = 4 if ( rnorm > zero ) then !  compute solution of primal problem fac = one - ddot ( m , h , 1 , w ( iy ), 1 ) if ( diff ( one + fac , one ) > zero ) then mode = 1 fac = one / fac do j = 1 , n x ( j ) = fac * ddot ( m , g ( 1 , j ), 1 , w ( iy ), 1 ) end do xnorm = dnrm2 ( n , x , 1 ) ! compute lagrange multipliers for primal problem w ( 1 ) = zero call dcopy ( m , w ( 1 ), 0 , w , 1 ) call daxpy ( m , fac , w ( iy ), 1 , w , 1 ) end if end if end if end if end if end subroutine ldp !******************************************************************************* !******************************************************************************* !> !  Replaced statement function in the original code. !  Returns  d = u - v . pure elemental function diff ( u , v ) result ( d ) implicit none real ( wp ), intent ( in ) :: u real ( wp ), intent ( in ) :: v real ( wp ) :: d d = u - v end function diff !******************************************************************************* !******************************************************************************* !> !  Nonnegative least squares algorithm. ! !  Given an m by n matrix, \\mathbf{A}, and an m-vector, \\mathbf{b}, !  compute an n-vector, \\mathbf{x}, that solves the least squares problem: ! !   \\mathbf{A} \\mathbf{x} = \\mathbf{b} subject to  \\mathbf{x} \\ge 0  ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine nnls ( a , mda , m , n , b , x , rnorm , w , zz , mode ) implicit none integer , intent ( in ) :: mda !! first dimensioning parameter for the array `a`. integer , intent ( in ) :: n real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! on entry, contains the `m` by `n` !! matrix, `a`. on exit, contains !! the product matrix, `q*a`, where `q` is an !! `m` by `m` orthogonal matrix generated implicitly by !! this subroutine. integer , intent ( in ) :: m real ( wp ), dimension ( m ), intent ( inout ) :: b !! on entry, contains the m-vector `b`. on exit, contains `q*b`. real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution vector. real ( wp ), intent ( out ) :: rnorm !! euclidean norm of the residual vector. real ( wp ), dimension ( n ), intent ( inout ) :: w !! array of working space.  on exit `w` will contain !! the dual solution vector. `w` will satisfy `w(i) = 0` !! for all `i` in set `p` and `w(i) <= 0` for all `i` in set `z`. real ( wp ), dimension ( m ), intent ( inout ) :: zz !! an m-array of working space. integer , intent ( out ) :: mode !! this is a success-failure flag with the following meanings: !! !! * ***1*** the solution has been computed successfully. !! * ***2*** the dimensions of the problem are bad. either `m<=0` or `n<=0`. !! * ***3*** iteration count exceeded. more than `3*n` iterations. integer :: i , ii , ip , iter , itmax , iz , iz1 , iz2 , izmax , j , jj , jz , l , npp1 , nsetp , rtnkey real ( wp ) :: alpha , asave , cc , sm , ss , t , temp , unorm , up , wmax , ztest real ( wp ), dimension ( 1 ) :: dummy integer , dimension ( n ) :: index !! an integer working array. !! the contents of this array define the sets !! `p` and `z` as follows: !! !! * `index(1:nsetp) = set p`. !! * `index(iz1:iz2) = set z`. !! !! where: `iz1 = nsetp + 1 = npp1`, `iz2 = n` real ( wp ), parameter :: factor = 0.01_wp mode = 1 if ( m <= 0 . or . n <= 0 ) then mode = 2 return end if iter = 0 itmax = 3 * n ! initialize the arrays index(1:n) and x(1:n). x = zero index = [( i , i = 1 , n )] iz2 = n iz1 = 1 nsetp = 0 npp1 = 1 ! ******  main loop begins here  ****** ! quit if all coefficients are already in the solution. ! or if m cols of a have been triangularized. 100 if ( iz1 <= iz2 . and . nsetp < m ) then ! compute components of the dual (negative gradient) vector w(). do iz = iz1 , iz2 j = index ( iz ) sm = zero do l = npp1 , m sm = sm + a ( l , j ) * b ( l ) end do w ( j ) = sm end do ! find largest positive w(j). 150 wmax = zero do iz = iz1 , iz2 j = index ( iz ) if ( w ( j ) > wmax ) then wmax = w ( j ) izmax = iz end if end do ! if wmax <= 0. go to termination. ! this indicates satisfaction of the kuhn-tucker conditions. if ( wmax > zero ) then iz = izmax j = index ( iz ) ! the sign of w(j) is ok for j to be moved to set p. ! begin the transformation and check new diagonal element to avoid ! near linear dependence. asave = a ( npp1 , j ) call h12 ( 1 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , dummy , 1 , 1 , 0 ) unorm = zero if ( nsetp /= 0 ) then do l = 1 , nsetp unorm = unorm + a ( l , j ) ** 2 end do end if unorm = sqrt ( unorm ) if ( diff ( unorm + abs ( a ( npp1 , j )) * factor , unorm ) > zero ) then ! col j is sufficiently independent.  copy b into zz, update zz ! and solve for ztest ( = proposed new value for x(j) ). do l = 1 , m zz ( l ) = b ( l ) end do call h12 ( 2 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , zz , 1 , 1 , 1 ) ztest = zz ( npp1 ) / a ( npp1 , j ) ! see if ztest is positive if ( ztest > zero ) then ! the index j=index(iz) has been selected to be moved from ! set z to set p. update b, update indices, apply householder ! transformations to cols in new set z, zero subdiagonal elts in ! col j, set w(j)=0. do l = 1 , m b ( l ) = zz ( l ) end do index ( iz ) = index ( iz1 ) index ( iz1 ) = j iz1 = iz1 + 1 nsetp = npp1 npp1 = npp1 + 1 if ( iz1 <= iz2 ) then do jz = iz1 , iz2 jj = index ( jz ) call h12 ( 2 , nsetp , npp1 , m , a ( 1 , j ), 1 , up , a ( 1 , jj ), 1 , mda , 1 ) end do end if if ( nsetp /= m ) then do l = npp1 , m a ( l , j ) = zero end do end if w ( j ) = zero ! solve the triangular system. ! store the solution temporarily in zz(). rtnkey = 1 goto 300 end if end if ! reject j as a candidate to be moved from set z to set p. ! restore a(npp1,j), set w(j)=0., and loop back to test dual ! coeffs again. a ( npp1 , j ) = asave w ( j ) = zero goto 150 end if end if ! ******  end of main loop  ****** ! come to here for termination. ! compute the norm of the final residual vector. 200 sm = zero if ( npp1 <= m ) then do i = npp1 , m sm = sm + b ( i ) ** 2 end do else do j = 1 , n w ( j ) = zero end do end if rnorm = sqrt ( sm ) return ! the following block of code is used as an internal subroutine ! to solve the triangular system, putting the solution in zz(). 300 do l = 1 , nsetp ip = nsetp + 1 - l if ( l /= 1 ) then do ii = 1 , ip zz ( ii ) = zz ( ii ) - a ( ii , jj ) * zz ( ip + 1 ) end do end if jj = index ( ip ) zz ( ip ) = zz ( ip ) / a ( ip , jj ) end do if ( rtnkey /= 1 . and . rtnkey /= 2 ) return ! ******  secondary loop begins here ****** ! iteration counter. iter = iter + 1 if ( iter > itmax ) then mode = 3 !write (*,'(/a)') ' nnls quitting on iteration count.' goto 200 end if ! see if all new constrained coeffs are feasible. ! if not compute alpha. alpha = two do ip = 1 , nsetp l = index ( ip ) if ( zz ( ip ) <= zero ) then t = - x ( l ) / ( zz ( ip ) - x ( l )) if ( alpha > t ) then alpha = t jj = ip end if end if end do ! if all new constrained coeffs are feasible then alpha will ! still = 2.    if so exit from secondary loop to main loop. if ( abs ( alpha - two ) <= zero ) then ! ******  end of secondary loop  ****** do ip = 1 , nsetp i = index ( ip ) x ( i ) = zz ( ip ) end do ! all new coeffs are positive.  loop back to beginning. goto 100 else ! otherwise use alpha which will be between 0. and 1. to ! interpolate between the old x and the new zz. do ip = 1 , nsetp l = index ( ip ) x ( l ) = x ( l ) + alpha * ( zz ( ip ) - x ( l )) end do ! modify a and b and the index arrays to move coefficient i ! from set p to set z. i = index ( jj ) 350 x ( i ) = zero if ( jj /= nsetp ) then jj = jj + 1 do j = jj , nsetp ii = index ( j ) index ( j - 1 ) = ii call g1 ( a ( j - 1 , ii ), a ( j , ii ), cc , ss , a ( j - 1 , ii )) a ( j , ii ) = zero do l = 1 , n if ( l /= ii ) then ! apply procedure g2 (cc,ss,a(j-1,l),a(j,l)) temp = a ( j - 1 , l ) a ( j - 1 , l ) = cc * temp + ss * a ( j , l ) a ( j , l ) = - ss * temp + cc * a ( j , l ) end if end do ! apply procedure g2 (cc,ss,b(j-1),b(j)) temp = b ( j - 1 ) b ( j - 1 ) = cc * temp + ss * b ( j ) b ( j ) = - ss * temp + cc * b ( j ) end do end if npp1 = nsetp nsetp = nsetp - 1 iz1 = iz1 - 1 index ( iz1 ) = i ! see if the remaining coeffs in set p are feasible.  they should ! be because of the way alpha was determined. ! if any are infeasible it is due to round-off error.  any ! that are nonpositive will be set to zero ! and moved from set p to set z. do jj = 1 , nsetp i = index ( jj ) if ( x ( i ) <= zero ) goto 350 end do ! copy b( ) into zz( ).  then solve again and loop back. do i = 1 , m zz ( i ) = b ( i ) end do rtnkey = 2 goto 300 end if end subroutine nnls !******************************************************************************* !******************************************************************************* !> !  Rank-deficient least squares algorithm using !  householder forward triangulation with column interchanges. ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine hfti ( a , mda , m , n , b , mdb , nb , tau , krank , rnorm , h , g ) implicit none integer , intent ( in ) :: mda !! the first dimensioning parameter of matrix `a` (mda >= m). integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: mdb !! first dimensioning parameter of matrix `b` (mdb>=max(m,n)) integer , intent ( in ) :: nb real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! the array `a` initially contains the  m \\times n  matrix \\mathbf{A} !! of the least squares problem  \\mathbf{A} \\mathbf{x} = \\mathbf{b} . !! either `m >= n` or `m < n` is permitted. !! there is no restriction on the rank of `a`. !! the matrix `a` will be modified by the subroutine. real ( wp ), intent ( in ) :: tau !! absolute tolerance parameter for pseudorank !! determination, provided by the user. integer , intent ( out ) :: krank !! pseudorank of `a`, set by the subroutine. real ( wp ), dimension ( nb ), intent ( out ) :: rnorm !! on exit, `rnorm(j)` will contain the euclidian !! norm of the residual vector for the problem !! defined by the `j-th` column vector of the array `b`. real ( wp ), dimension ( n ), intent ( inout ) :: h !! array of working space real ( wp ), dimension ( n ), intent ( inout ) :: g !! array of working space real ( wp ), dimension ( mdb , nb ), intent ( inout ) :: b !! if `nb = 0` the subroutine will make no reference !! to the array `b`. if `nb > 0` the array `b` must !! initially contain the `m x nb` matrix `b` of the !! the least squares problem `ax = b` and on return !! the array `b` will contain the `n x nb` solution `x`. integer :: i , ii , ip1 , j , jb , jj , k , kp1 , l , ldiag , lmax real ( wp ) :: hmax , sm , tmp logical :: need_lmax integer , dimension ( n ) :: ip !! integer array of working space !! recording permutation indices of column vectors real ( wp ), parameter :: factor = 0.001_wp k = 0 ldiag = min ( m , n ) if ( ldiag <= 0 ) then ! the solution vectors, x, are now ! in the first  n  rows of the array b(,). krank = k return else do j = 1 , ldiag need_lmax = . true . if ( j /= 1 ) then ! update squared column lengths and find lmax lmax = j do l = j , n h ( l ) = h ( l ) - a ( j - 1 , l ) ** 2 if ( h ( l ) > h ( lmax ) ) lmax = l end do if ( diff ( hmax + factor * h ( lmax ), hmax ) > zero ) need_lmax = . false . end if if ( need_lmax ) then ! compute squared column lengths and find lmax lmax = j do l = j , n h ( l ) = zero do i = j , m h ( l ) = h ( l ) + a ( i , l ) ** 2 end do if ( h ( l ) > h ( lmax ) ) lmax = l end do hmax = h ( lmax ) end if ! lmax has been determined ! do column interchanges if needed. ip ( j ) = lmax if ( ip ( j ) /= j ) then do i = 1 , m tmp = a ( i , j ) a ( i , j ) = a ( i , lmax ) a ( i , lmax ) = tmp end do h ( lmax ) = h ( j ) end if ! compute the j-th transformation and apply it to a and b. call h12 ( 1 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), a ( 1 , j + 1 ), 1 , mda , n - j ) call h12 ( 2 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), b , 1 , mdb , nb ) end do ! determine the pseudorank, k, using the tolerance, tau. do j = 1 , ldiag if ( abs ( a ( j , j )) <= tau ) exit end do k = j - 1 kp1 = j end if ! compute the norms of the residual vectors. if ( nb > 0 ) then do jb = 1 , nb tmp = zero if ( kp1 <= m ) then do i = kp1 , m tmp = tmp + b ( i , jb ) ** 2 end do end if rnorm ( jb ) = sqrt ( tmp ) end do end if ! special for pseudorank = 0 if ( k > 0 ) then ! if the pseudorank is less than n compute householder ! decomposition of first k rows. if ( k /= n ) then do ii = 1 , k i = kp1 - ii call h12 ( 1 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), a , mda , 1 , i - 1 ) end do end if if ( nb > 0 ) then do jb = 1 , nb ! solve the k by k triangular system. do l = 1 , k sm = zero i = kp1 - l if ( i /= k ) then ip1 = i + 1 do j = ip1 , k sm = sm + a ( i , j ) * b ( j , jb ) end do end if b ( i , jb ) = ( b ( i , jb ) - sm ) / a ( i , i ) end do ! complete computation of solution vector. if ( k /= n ) then do j = kp1 , n b ( j , jb ) = zero end do do i = 1 , k call h12 ( 2 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), b ( 1 , jb ), 1 , mdb , 1 ) end do end if ! re-order the solution vector to compensate for the ! column interchanges. do jj = 1 , ldiag j = ldiag + 1 - jj if ( ip ( j ) /= j ) then l = ip ( j ) tmp = b ( l , jb ) b ( l , jb ) = b ( j , jb ) b ( j , jb ) = tmp end if end do end do end if else if ( nb > 0 ) then do jb = 1 , nb do i = 1 , n b ( i , jb ) = zero end do end do end if krank = k end subroutine hfti !******************************************************************************* !******************************************************************************* !> !  Construction and/or application of a single !  householder transformation  Q = I + u(u&#94;t)/b . ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine h12 ( mode , lpivot , l1 , m , u , iue , up , c , ice , icv , ncv ) implicit none integer , intent ( in ) :: mode !! `1` or `2` -- selects algorithm ***h1*** to construct and apply a !! householder transformation, or algorithm ***h2*** to apply a !! previously constructed transformation. integer , intent ( in ) :: lpivot !! the index of the pivot element integer , intent ( in ) :: l1 !! if `l1 <= m` the transformation will be constructed to !! zero elements indexed from `l1` through `m`. !! if `l1 > m` the subroutine does an identity transformation. integer , intent ( in ) :: m !! see `li`. integer , intent ( in ) :: iue !! see `u`. real ( wp ), dimension ( iue , * ), intent ( inout ) :: u !! on entry with `mode = 1`, `u` contains the pivot !! vector.  `iue` is the storage increment between elements. !! on exit when `mode = 1`, `u` and `up` contain quantities !! defining the vector `u` of the householder transformation. !! on entry with `mode = 2`, `u` and `up` should contain !! quantities previously computed with `mode = 1`.  these will !! not be modified during the entry with `mode = 2`. !! `dimension[u(iue,m)]` real ( wp ), intent ( inout ) :: up !! see `u`. real ( wp ), dimension ( * ), intent ( inout ) :: c !! on entry with `mode = 1 or 2`, `c` contains a matrix which !! will be regarded as a set of vectors to which the !! householder transformation is to be applied. !! on exit `c` contains the set of transformed vectors. integer , intent ( in ) :: ice !! storage increment between elements of vectors in `c`. integer , intent ( in ) :: icv !! storage increment between vectors in `c`. integer , intent ( in ) :: ncv !! number of vectors in `c` to be transformed. if `ncv <= 0` !! no operations will be done on `c`. integer :: i , i2 , i3 , i4 , incr , j real ( wp ) :: b , cl , clinv , sm if ( 0 >= lpivot . or . lpivot >= l1 . or . l1 > m ) return cl = abs ( u ( 1 , lpivot )) if ( mode /= 2 ) then ! construct the transformation. do j = l1 , m cl = max ( abs ( u ( 1 , j )), cl ) end do if ( cl <= zero ) return clinv = one / cl sm = ( u ( 1 , lpivot ) * clinv ) ** 2 do j = l1 , m sm = sm + ( u ( 1 , j ) * clinv ) ** 2 end do cl = cl * sqrt ( sm ) if ( u ( 1 , lpivot ) > zero ) cl = - cl up = u ( 1 , lpivot ) - cl u ( 1 , lpivot ) = cl else if ( cl <= zero ) then return end if if ( ncv > 0 ) then ! apply the transformation i+u*(u**t)/b to c. b = up * u ( 1 , lpivot ) ! b must be nonpositive here. if ( b < zero ) then b = one / b i2 = 1 - icv + ice * ( lpivot - 1 ) incr = ice * ( l1 - lpivot ) do j = 1 , ncv i2 = i2 + icv i3 = i2 + incr i4 = i3 sm = c ( i2 ) * up do i = l1 , m sm = sm + c ( i3 ) * u ( 1 , i ) i3 = i3 + ice end do if ( abs ( sm ) > zero ) then sm = sm * b c ( i2 ) = c ( i2 ) + sm * up do i = l1 , m c ( i4 ) = c ( i4 ) + sm * u ( 1 , i ) i4 = i4 + ice end do end if end do end if end if end subroutine h12 !******************************************************************************* !******************************************************************************* !> !  Compute orthogonal rotation matrix. ! !  Compute matrix  \\left[ \\begin{array}{cc} c & s \\\\ -s & c \\end{array} \\right]  !  so that ! !   !  \\left[ \\begin{array}{cc} c & s \\\\ -s & c \\end{array} \\right] !  \\left[ \\begin{array}{c} a \\\\ b \\end{array} \\right]  = !  \\left[ \\begin{array}{c} \\sqrt{a&#94;2+b&#94;2} \\\\ 0 \\end{array} \\right] !   ! !  Compute  \\sigma = \\sqrt{a&#94;2+b&#94;2}  ! !   \\sigma  is computed last to allow for the possibility that !  `sig` may be in the same location as `a` or `b`. ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine g1 ( a , b , c , s , sig ) implicit none real ( wp ) :: a real ( wp ) :: b real ( wp ) :: sig real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s real ( wp ) :: xr , yr if ( abs ( a ) > abs ( b ) ) then xr = b / a yr = sqrt ( one + xr ** 2 ) c = sign ( one / yr , a ) s = c * xr sig = abs ( a ) * yr else if ( abs ( b ) > zero ) then xr = a / b yr = sqrt ( one + xr ** 2 ) s = sign ( one / yr , b ) c = s * xr sig = abs ( b ) * yr else sig = zero c = zero s = one end if end if end subroutine g1 !******************************************************************************* !******************************************************************************* !> !  LDL&#94;T - rank-one - update ! !### Purpose: ! !  Updates the LDL&#94;T factors of matrix A !  by rank-one matrix \\sigma z z&#94;T . ! !### Reference !  * R. Fletcher, M.J.D. Powell, !    \"[On the modification of LDL' factorization](http://www.ams.org/journals/mcom/1974-28-128/S0025-5718-1974-0359297-1/S0025-5718-1974-0359297-1.pdf)\". !    Mathematics of Computation Vol. 28, No. 128, p. 1067-1087, October 1974. ! !### History !  * D. Kraft, DFVLR - institut fuer dynamik der flugsysteme !    d-8031  oberpfaffenhofen !  * Status: 15. january 1980 subroutine ldl ( n , a , z , sigma , w ) implicit none integer , intent ( in ) :: n !! order of the coefficient matrix `a` real ( wp ), intent ( in ) :: sigma !! scalar factor by which the modifying dyade z z&#94;T is multiplied. real ( wp ), dimension ( * ), intent ( inout ) :: a !! ***In:*** positive definite matrix of dimension `n`; !! only the lower triangle is used and is stored column by !! column as one dimensional array of dimension `n*(n+1)/2`. !! !! ***Out:*** updated LDL&#94;T factors real ( wp ), dimension ( * ), intent ( inout ) :: w !! working array of dimension `n` (used only if  \\sigma \\lt 0  ). real ( wp ), dimension ( * ), intent ( inout ) :: z !! vector of dimension `n` of updating elements. integer :: i , ij , j real ( wp ) :: t , v , u , tp , beta , alpha , delta , gamma if ( abs ( sigma ) > zero ) then ij = 1 t = one / sigma if ( sigma <= zero ) then ! prepare negative update do i = 1 , n w ( i ) = z ( i ) end do do i = 1 , n v = w ( i ) t = t + v * v / a ( ij ) do j = i + 1 , n ij = ij + 1 w ( j ) = w ( j ) - v * a ( ij ) end do ij = ij + 1 end do if ( t >= zero ) t = epmach / sigma do i = 1 , n j = n + 1 - i ij = ij - i u = w ( j ) w ( j ) = t t = t - u * u / a ( ij ) end do end if ! here updating begins do i = 1 , n v = z ( i ) delta = v / a ( ij ) if ( sigma < zero ) tp = w ( i ) if ( sigma > zero ) tp = t + delta * v alpha = tp / t a ( ij ) = alpha * a ( ij ) if ( i == n ) return beta = delta / tp if ( alpha > four ) then gamma = t / tp do j = i + 1 , n ij = ij + 1 u = a ( ij ) a ( ij ) = gamma * u + beta * z ( j ) z ( j ) = z ( j ) - v * u end do else do j = i + 1 , n ij = ij + 1 z ( j ) = z ( j ) - v * a ( ij ) a ( ij ) = a ( ij ) + beta * z ( j ) end do end if ij = ij + 1 t = tp end do end if end subroutine ldl !******************************************************************************* !******************************************************************************* !> !  Linesearch without derivatives (used by [[slsqp]] if `linesearch_mode=2`). !  Returns the abscissa approximating the point where `f` attains a minimum. ! !### purpose: ! !  to find the argument linmin where the function `f` takes it's minimum !  on the interval `ax`, `bx`. It uses a combination of golden section !  and successive quadratic interpolation. ! !### Reference ! !  This function subprogram is a slightly modified version of the !  ALGOL 60 procedure `localmin` given in R.P. Brent: !  \"[Algorithms for minimization without derivatives](https://maths-people.anu.edu.au/~brent/pub/pub011.html)\", !  Prentice-Hall (1973). ! !### History ! !  * Kraft, D., DFVLR - institut fuer dynamik der flugsysteme !    d-8031  oberpfaffenhofen !  * status: 31. august 1984 !  * Jacob Williams, Jan 2016, Refactored into modern Fortran. !    Added saved variables as `inout`s to make the routine thread-safe. real ( wp ) function linmin ( mode , ax , bx , f , tol ,& a , b , d , e , p , q , r , u , v ,& w , x , m , fu , fv , fw , fx , tol1 , tol2 ) implicit none integer , intent ( inout ) :: mode !! controls reverse communication !! must be set to 0 initially, returns with intermediate !! values 1 and 2 which must not be changed by the user, !! ends with convergence with value 3. real ( wp ) :: f !! function value at `linmin` which is to be brought in by !! reverse communication controlled by `mode` real ( wp ), intent ( in ) :: tol !! desired length of interval of uncertainty of final result real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( inout ) :: a , b , d , e , p , q , r , u , v , w , x , m , fu , fv , fw , fx , tol1 , tol2 real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! golden section ratio = `0.381966011` real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) !! square - root of machine precision select case ( mode ) case ( 1 ) ! main loop starts here fx = f fv = fx fw = fv case ( 2 ) fu = f ! update a, b, v, w, and x if ( fu > fx ) then if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . abs ( w - x ) <= zero ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . abs ( v - x ) <= zero . or . abs ( v - w ) <= zero ) then v = u fv = fu end if else if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu end if case default ! initialization a = ax b = bx e = zero v = a + c * ( b - a ) w = v x = w linmin = x mode = 1 return end select m = 0.5_wp * ( a + b ) tol1 = eps * abs ( x ) + tol tol2 = tol1 + tol1 ! test convergence if ( abs ( x - m ) <= tol2 - 0.5_wp * ( b - a ) ) then ! end of main loop linmin = x mode = 3 else r = zero q = r p = q if ( abs ( e ) > tol1 ) then ! fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = q - r q = q + q if ( q > zero ) p = - p if ( q < zero ) q = - q r = e e = d end if ! is parabola acceptable if ( abs ( p ) >= 0.5_wp * abs ( q * r ) . or . p <= q * ( a - x ) . or . p >= q * ( b - x ) ) then ! golden section step if ( x >= m ) e = a - x if ( x < m ) e = b - x d = c * e else ! parabolic interpolation step d = p / q ! f must not be evaluated too close to a or b if ( u - a < tol2 ) d = sign ( tol1 , m - x ) if ( b - u < tol2 ) d = sign ( tol1 , m - x ) end if ! f must not be evaluated too close to x if ( abs ( d ) < tol1 ) d = sign ( tol1 , d ) u = x + d linmin = u mode = 2 end if end function linmin !******************************************************************************* !******************************************************************************* !> !  enforce the bound constraints on x. subroutine enforce_bounds ( x , xl , xu ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( in ) :: xl !! lower bounds (must be same dimension as `x`) real ( wp ), dimension (:), intent ( in ) :: xu !! upper bounds (must be same dimension as `x`) where ( x < xl ) x = xl elsewhere ( x > xu ) x = xu end where end subroutine enforce_bounds !******************************************************************************* !******************************************************************************* !> !  Destructor for [[slsqpb_data]] type. subroutine destroy_slsqpb_data ( me ) implicit none class ( slsqpb_data ), intent ( out ) :: me end subroutine destroy_slsqpb_data !******************************************************************************* !******************************************************************************* !> !  Destructor for [[linmin_data]] type. subroutine destroy_linmin_data ( me ) implicit none class ( linmin_data ), intent ( out ) :: me end subroutine destroy_linmin_data !******************************************************************************* !******************************************************************************* end module slsqp_core !*******************************************************************************","tags":"","loc":"sourcefile/slsqp_core.f90.html"},{"title":"slsqp_solver – slsqp ","text":"type, public :: slsqp_solver The main class used to interface with the SLSQP solver. Inherits type~~slsqp_solver~~InheritsGraph type~slsqp_solver slsqp_solver type~slsqpb_data slsqpb_data type~slsqp_solver->type~slsqpb_data slsqpb type~linmin_data linmin_data type~slsqp_solver->type~linmin_data linmin Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables n m meq max_iter acc tolf toldf toldx gradient_mode gradient_delta alphamin alphamax iprint xl xu l_w w f g report linesearch_mode linmin slsqpb user_triggered_stop Type-Bound Procedures initialize destroy optimize abort report_message Source Code slsqp_solver Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of optimization variables ( ) integer, private :: m = 0 number of constraints ( ) integer, private :: meq = 0 number of equality constraints ( ) integer, private :: max_iter = 0 maximum number of iterations real(kind=wp), private :: acc = zero accuracy tolerance real(kind=wp), private :: tolf = -one accuracy tolerance over f:  if then stop real(kind=wp), private :: toldf = -one accuracy tolerance over df: if then stop.\n It's different from acc in the case of positive derivative real(kind=wp), private :: toldx = -one accuracy tolerance over xf: if then stop integer, private :: gradient_mode = 0 how the gradients are computed: 0 - use the user-supplied g subroutine. [default] 1 - approximate by basic backward differences 2 - approximate by basic forward differences 3 - approximate by basic central differences real(kind=wp), private :: gradient_delta = 1.0e8_wp perturbation step size to approximate gradients\n by finite differences ( gradient_mode 1-3). real(kind=wp), private :: alphamin = 0.1_wp min for line search real(kind=wp), private :: alphamax = 1.0_wp max for line search integer, private :: iprint = output_unit unit number of status printing (0 for no printing) real(kind=wp), private, dimension(:), allocatable :: xl lower bound on x real(kind=wp), private, dimension(:), allocatable :: xu upper bound on x integer, private :: l_w = 0 size of w real(kind=wp), private, dimension(:), allocatable :: w real work array procedure( func ), private, pointer :: f => null() problem function subroutine procedure( grad ), private, pointer :: g => null() gradient subroutine procedure( iterfunc ), private, pointer :: report => null() for reporting an iteration integer, private :: linesearch_mode = 1 linesearch mode: 1 = inexact (Armijo) linesearch, 2 = exact linesearch. type( linmin_data ), private :: linmin data formerly within linmin .\n Only used when linesearch_mode=2 type( slsqpb_data ), private :: slsqpb data formerly within slsqpb . logical, private :: user_triggered_stop = .false. if the abort method has been called\n to stop the iterations Type-Bound Procedures procedure, public :: initialize => initialize_slsqp private subroutine initialize_slsqp (me, n, m, meq, max_iter, acc, f, g, xl, xu, status_ok, linesearch_mode, iprint, report, alphamin, alphamax, gradient_mode, gradient_delta, tolf, toldf, toldx) initialize the slsqp_solver class.  see slsqp for more details. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: n the number of variables, integer, intent(in) :: m total number of constraints, integer, intent(in) :: meq number of equality constraints, integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: acc accuracy procedure( func ) :: f problem function procedure( grad ) :: g function to compute gradients (must be\n associated if gradient_mode=0 ) real(kind=wp), intent(in), dimension(n) :: xl lower bounds on x real(kind=wp), intent(in), dimension(n) :: xu upper bounds on x logical, intent(out) :: status_ok will be false if there were errors integer, intent(in), optional :: linesearch_mode 1 = inexact (default), 2 = exact integer, intent(in), optional :: iprint unit number of status messages (default=output_unit) procedure( iterfunc ), optional :: report user-defined procedure that will be called once per iteration real(kind=wp), intent(in), optional :: alphamin minimum alpha for linesearch [default 0.1] real(kind=wp), intent(in), optional :: alphamax maximum alpha for linesearch [default 1.0] integer, intent(in), optional :: gradient_mode how the gradients are to be computed: 0 - use the user-supplied g subroutine. [default] 1 - approximate by basic backward differences 2 - approximate by basic forward differences 3 - approximate by basic central differences real(kind=wp), intent(in), optional :: gradient_delta perturbation step size (>epsilon) to compute the approximated\n gradient by finite differences ( gradient_mode 1-3).\n note that this is an absolute step that does not respect\n the xl or xu variable bounds. real(kind=wp), intent(in), optional :: tolf stopping criterion if then stop. real(kind=wp), intent(in), optional :: toldf stopping criterion if then stop real(kind=wp), intent(in), optional :: toldx stopping criterion if then stop procedure, public :: destroy => destroy_slsqp private subroutine destroy_slsqp (me) destructor for slsqp_solver . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(out) :: me procedure, public :: optimize => slsqp_wrapper private subroutine slsqp_wrapper (me, x, istat, iterations, status_message) main routine for calling slsqp . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x in: initial optimization variables, out: solution. integer, intent(out) :: istat status code (see mode in slsqp ). integer, intent(out), optional :: iterations number of iterations character(len=:), intent(out), optional allocatable :: status_message string status message\n corresponding to istat procedure, public :: abort => stop_iterations private subroutine stop_iterations (me) A method that the user can call to stop the iterations.\n  (it can be called in any of the functions).\n  SLSQP will stop at the end of the next iteration. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me procedure, private :: report_message for reporting messages to the user private subroutine report_message (me, str, ival, rval, fatal) Report a message from an slsqp_solver class. This uses the iprint variable in the class as the unit number for printing. Note: for fatal errors,\n  if no unit is specified, the error_unit is used. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(in) :: me character(len=*), intent(in) :: str the message to report. integer, intent(in), optional :: ival optional integer to print after the message. real(kind=wp), intent(in), optional :: rval optional real to print after the message. logical, intent(in), optional :: fatal if True, then the program is stopped (default=False). Source Code type , public :: slsqp_solver !! The main class used to interface with the SLSQP solver. private integer :: n = 0 !! number of optimization variables ( n > 0 ) integer :: m = 0 !! number of constraints ( m \\ge 0 ) integer :: meq = 0 !! number of equality constraints ( m \\ge m_{eq} \\ge 0 ) integer :: max_iter = 0 !! maximum number of iterations real ( wp ) :: acc = zero !! accuracy tolerance real ( wp ) :: tolf = - one !! accuracy tolerance over f:  if  |f| < tolf  then stop real ( wp ) :: toldf = - one !! accuracy tolerance over df: if  |f_{n+1} - f_n| < toldf  then stop. !! It's different from `acc` in the case of positive derivative real ( wp ) :: toldx = - one !! accuracy tolerance over xf: if  |x_{n+1} - x_n| < toldx  then stop integer :: gradient_mode = 0 !! how the gradients are computed: !! !! * 0 - use the user-supplied `g` subroutine. [default] !! * 1 - approximate by basic backward differences !! * 2 - approximate by basic forward differences !! * 3 - approximate by basic central differences real ( wp ) :: gradient_delta = 1.0e8_wp !! perturbation step size to approximate gradients !! by finite differences (`gradient_mode` 1-3). !these two were not in the original code: real ( wp ) :: alphamin = 0.1_wp !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ) :: alphamax = 1.0_wp !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: iprint = output_unit !! unit number of status printing (0 for no printing) real ( wp ), dimension (:), allocatable :: xl !! lower bound on x real ( wp ), dimension (:), allocatable :: xu !! upper bound on x integer :: l_w = 0 !! size of `w` real ( wp ), dimension (:), allocatable :: w !! real work array procedure ( func ), pointer :: f => null () !! problem function subroutine procedure ( grad ), pointer :: g => null () !! gradient subroutine procedure ( iterfunc ), pointer :: report => null () !! for reporting an iteration integer :: linesearch_mode = 1 !! linesearch mode: !! !! * `1` = inexact (Armijo) linesearch, !! * `2` = exact linesearch. type ( linmin_data ) :: linmin !! data formerly within [[linmin]]. !! Only used when `linesearch_mode=2` type ( slsqpb_data ) :: slsqpb !! data formerly within [[slsqpb]]. logical :: user_triggered_stop = . false . !! if the `abort` method has been called !! to stop the iterations contains private procedure , public :: initialize => initialize_slsqp procedure , public :: destroy => destroy_slsqp procedure , public :: optimize => slsqp_wrapper procedure , public :: abort => stop_iterations procedure :: report_message !! for reporting messages to the user end type slsqp_solver","tags":"","loc":"type/slsqp_solver.html"},{"title":"linmin_data – slsqp ","text":"type, public :: linmin_data data formerly saved in linmin routine. Inherited by type~~linmin_data~~InheritedByGraph type~linmin_data linmin_data type~slsqp_solver slsqp_solver type~slsqp_solver->type~linmin_data linmin Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a b d e p q r u v w x m fu fv fw fx tol1 tol2 Type-Bound Procedures destroy Source Code linmin_data Components Type Visibility Attributes Name Initial real(kind=wp), public :: a = zero real(kind=wp), public :: b = zero real(kind=wp), public :: d = zero real(kind=wp), public :: e = zero real(kind=wp), public :: p = zero real(kind=wp), public :: q = zero real(kind=wp), public :: r = zero real(kind=wp), public :: u = zero real(kind=wp), public :: v = zero real(kind=wp), public :: w = zero real(kind=wp), public :: x = zero real(kind=wp), public :: m = zero real(kind=wp), public :: fu = zero real(kind=wp), public :: fv = zero real(kind=wp), public :: fw = zero real(kind=wp), public :: fx = zero real(kind=wp), public :: tol1 = zero real(kind=wp), public :: tol2 = zero Type-Bound Procedures procedure, public :: destroy => destroy_linmin_data private subroutine destroy_linmin_data (me) Destructor for linmin_data type. Arguments Type Intent Optional Attributes Name class( linmin_data ), intent(out) :: me Source Code type , public :: linmin_data !! data formerly saved in [[linmin]] routine. real ( wp ) :: a = zero real ( wp ) :: b = zero real ( wp ) :: d = zero real ( wp ) :: e = zero real ( wp ) :: p = zero real ( wp ) :: q = zero real ( wp ) :: r = zero real ( wp ) :: u = zero real ( wp ) :: v = zero real ( wp ) :: w = zero real ( wp ) :: x = zero real ( wp ) :: m = zero real ( wp ) :: fu = zero real ( wp ) :: fv = zero real ( wp ) :: fw = zero real ( wp ) :: fx = zero real ( wp ) :: tol1 = zero real ( wp ) :: tol2 = zero contains procedure :: destroy => destroy_linmin_data end type linmin_data","tags":"","loc":"type/linmin_data.html"},{"title":"slsqpb_data – slsqp ","text":"type, public :: slsqpb_data data formerly saved in slsqpb . Inherited by type~~slsqpb_data~~InheritedByGraph type~slsqpb_data slsqpb_data type~slsqp_solver slsqp_solver type~slsqp_solver->type~slsqpb_data slsqpb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables t f0 h1 h2 h3 h4 t0 gs tol alpha line iexact incons ireset itermx n1 n2 n3 Type-Bound Procedures destroy Source Code slsqpb_data Components Type Visibility Attributes Name Initial real(kind=wp), public :: t = zero real(kind=wp), public :: f0 = zero real(kind=wp), public :: h1 = zero real(kind=wp), public :: h2 = zero real(kind=wp), public :: h3 = zero real(kind=wp), public :: h4 = zero real(kind=wp), public :: t0 = zero real(kind=wp), public :: gs = zero real(kind=wp), public :: tol = zero real(kind=wp), public :: alpha = zero integer, public :: line = 0 integer, public :: iexact = 0 integer, public :: incons = 0 integer, public :: ireset = 0 integer, public :: itermx = 0 integer, public :: n1 = 0 integer, public :: n2 = 0 integer, public :: n3 = 0 Type-Bound Procedures procedure, public :: destroy => destroy_slsqpb_data private subroutine destroy_slsqpb_data (me) Destructor for slsqpb_data type. Arguments Type Intent Optional Attributes Name class( slsqpb_data ), intent(out) :: me Source Code type , public :: slsqpb_data !! data formerly saved in [[slsqpb]]. real ( wp ) :: t = zero real ( wp ) :: f0 = zero real ( wp ) :: h1 = zero real ( wp ) :: h2 = zero real ( wp ) :: h3 = zero real ( wp ) :: h4 = zero real ( wp ) :: t0 = zero real ( wp ) :: gs = zero real ( wp ) :: tol = zero real ( wp ) :: alpha = zero integer :: line = 0 integer :: iexact = 0 integer :: incons = 0 integer :: ireset = 0 integer :: itermx = 0 integer :: n1 = 0 integer :: n2 = 0 integer :: n3 = 0 contains procedure :: destroy => destroy_slsqpb_data end type slsqpb_data","tags":"","loc":"type/slsqpb_data.html"},{"title":"func – slsqp","text":"abstract interface private subroutine func(me, x, f, c) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. Description for computing the function","tags":"","loc":"interface/func.html"},{"title":"grad – slsqp","text":"abstract interface private subroutine grad(me, x, g, a) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) Description for computing the gradients","tags":"","loc":"interface/grad.html"},{"title":"iterfunc – slsqp","text":"abstract interface private subroutine iterfunc(me, iter, x, f, c) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(in) :: f value of the objective function real(kind=wp), intent(in), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. Description for reporting an iteration","tags":"","loc":"interface/iterfunc.html"},{"title":"ddot – slsqp","text":"public function ddot(n, dx, incx, dy, incy) forms the dot product of two vectors.\n  uses unrolled loops for increments equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Return Value real(kind=wp) Called by proc~~ddot~~CalledByGraph proc~ddot ddot proc~slsqpb slsqpb proc~slsqpb->proc~ddot proc~lsq lsq proc~slsqpb->proc~lsq proc~lsq->proc~ddot proc~lsei lsei proc~lsq->proc~lsei proc~ldp ldp proc~ldp->proc~ddot proc~lsi lsi proc~lsi->proc~ddot proc~lsi->proc~ldp proc~lsei->proc~ddot proc~lsei->proc~lsi proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ddot Source Code real ( wp ) function ddot ( n , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) , dtemp integer :: i , incx , incy , ix , iy , m , mp1 , n ddot = zero dtemp = zero if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) end do if ( n < 5 ) then ddot = dtemp return end if end if mp1 = m + 1 do i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + & dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) end do ddot = dtemp else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy end do ddot = dtemp end if end function ddot","tags":"","loc":"proc/ddot.html"},{"title":"dnrm2 – slsqp","text":"public function dnrm2(n, x, incx) Function that returns the Euclidean norm of a vector . Further details this version written on 25-october-1982. modified on 14-october-1993 to inline the call to dlassq.\n    sven hammarling, nag ltd. Converted to modern Fortran, Jacob Williams, Jan. 2016. Note Replaced original SLSQP routine with this one from BLAS . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: x integer, intent(in) :: incx Return Value real(kind=wp) Called by proc~~dnrm2~~CalledByGraph proc~dnrm2 dnrm2 proc~lsi lsi proc~lsi->proc~dnrm2 proc~ldp ldp proc~lsi->proc~ldp proc~check_convergence check_convergence proc~check_convergence->proc~dnrm2 proc~ldp->proc~dnrm2 proc~lsei lsei proc~lsei->proc~dnrm2 proc~lsei->proc~lsi proc~slsqpb slsqpb proc~slsqpb->proc~check_convergence proc~lsq lsq proc~slsqpb->proc~lsq proc~lsq->proc~lsei proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dnrm2 Source Code real ( wp ) function dnrm2 ( n , x , incx ) implicit none integer , intent ( in ) :: incx integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ) :: absxi , norm , scale , ssq integer :: ix if ( n < 1 . or . incx < 1 ) then norm = zero elseif ( n == 1 ) then norm = abs ( x ( 1 )) else scale = zero ssq = one ! the following loop is equivalent to this call to the lapack ! auxiliary routine: ! call dlassq( n, x, incx, scale, ssq ) do ix = 1 , 1 + ( n - 1 ) * incx , incx if ( abs ( x ( ix )) > zero ) then absxi = abs ( x ( ix )) if ( scale < absxi ) then ssq = one + ssq * ( scale / absxi ) ** 2 scale = absxi else ssq = ssq + ( absxi / scale ) ** 2 end if end if end do norm = scale * sqrt ( ssq ) end if dnrm2 = norm end function dnrm2","tags":"","loc":"proc/dnrm2.html"},{"title":"daxpy – slsqp","text":"public subroutine daxpy(n, da, dx, incx, dy, incy) constant times a vector plus a vector.\n  uses unrolled loops for increments equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Called by proc~~daxpy~~CalledByGraph proc~daxpy daxpy proc~slsqpb slsqpb proc~slsqpb->proc~daxpy proc~lsq lsq proc~slsqpb->proc~lsq proc~lsi lsi proc~lsi->proc~daxpy proc~ldp ldp proc~lsi->proc~ldp proc~ldp->proc~daxpy proc~lsei lsei proc~lsei->proc~lsi proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp proc~lsq->proc~lsei Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code daxpy Source Code subroutine daxpy ( n , da , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) , da integer :: i , incx , incy , ix , iy , m , mp1 , n if ( n <= 0 ) return if ( abs ( da ) <= zero ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 4 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dy ( i ) + da * dx ( i ) end do if ( n < 4 ) return end if mp1 = m + 1 do i = mp1 , n , 4 dy ( i ) = dy ( i ) + da * dx ( i ) dy ( i + 1 ) = dy ( i + 1 ) + da * dx ( i + 1 ) dy ( i + 2 ) = dy ( i + 2 ) + da * dx ( i + 2 ) dy ( i + 3 ) = dy ( i + 3 ) + da * dx ( i + 3 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dy ( iy ) + da * dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine daxpy","tags":"","loc":"proc/daxpy.html"},{"title":"dcopy – slsqp","text":"public subroutine dcopy(n, dx, incx, dy, incy) copies a vector, x, to a vector, y.\n  uses unrolled loops for increments equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Called by proc~~dcopy~~CalledByGraph proc~dcopy dcopy proc~lsq lsq proc~lsq->proc~dcopy proc~lsei lsei proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~dcopy proc~slsqpb->proc~lsq proc~lsei->proc~dcopy proc~lsi lsi proc~lsei->proc~lsi proc~ldp ldp proc~ldp->proc~dcopy proc~lsi->proc~ldp proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dcopy Source Code subroutine dcopy ( n , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) integer :: i , incx , incy , ix , iy , m , mp1 , n if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 7 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dx ( i ) end do if ( n < 7 ) return end if mp1 = m + 1 do i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine dcopy","tags":"","loc":"proc/dcopy.html"},{"title":"dscal – slsqp","text":"public subroutine dscal(n, da, dx, incx) scales a vector by a constant.\n  uses unrolled loops for increment equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx Called by proc~~dscal~~CalledByGraph proc~dscal dscal proc~slsqpb slsqpb proc~slsqpb->proc~dscal proc~lsq lsq proc~slsqpb->proc~lsq proc~lsq->proc~dscal proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dscal Source Code subroutine dscal ( n , da , dx , incx ) implicit none real ( wp ) :: da , dx ( * ) integer :: i , incx , m , mp1 , n , nincx if ( n <= 0 . or . incx <= 0 ) return if ( incx == 1 ) then ! code for increment equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dx ( i ) = da * dx ( i ) end do if ( n < 5 ) return end if mp1 = m + 1 do i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) end do else ! code for increment not equal to 1 nincx = n * incx do i = 1 , nincx , incx dx ( i ) = da * dx ( i ) end do end if end subroutine dscal","tags":"","loc":"proc/dscal.html"},{"title":"mode_to_status_message – slsqp","text":"private pure function mode_to_status_message(imode) result(message) Convert the slsqp mode flag to a message string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imode Return Value character(len=:),\n  allocatable Called by proc~~mode_to_status_message~~CalledByGraph proc~mode_to_status_message mode_to_status_message proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~mode_to_status_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mode_to_status_message Source Code pure function mode_to_status_message ( imode ) result ( message ) implicit none integer , intent ( in ) :: imode character ( len = :), allocatable :: message select case ( imode ) case ( 0 ) !required accuracy for solution obtained message = 'Required accuracy for solution obtained' case ( - 100 ) message = 'Invalid size(x) in slsqp_wrapper' case ( - 101 ) message = 'Invalid linesearch_mode in slsqp_wrapper' case ( - 102 ) message = 'Function is not associated' case ( - 103 ) message = 'Gradient function is not associated' case ( - 104 ) message = 'Invalid gradient mode' case ( - 105 ) message = 'Invalid perturbation step size for finite difference gradients' case ( - 2 ) message = 'User-triggered stop of slsqp' case ( 1 , - 1 ) message = 'In progress' case ( 2 ) message = 'Number of equality constraints larger than n' case ( 3 ) message = 'More than 3*n iterations in lsq subproblem' case ( 4 ) message = 'Inequality constraints incompatible' case ( 5 ) message = 'Singular matrix e in lsq subproblem' case ( 6 ) message = 'Singular matrix c in lsq subproblem' case ( 7 ) message = 'Rank-deficient equality constraint subproblem hfti' case ( 8 ) message = 'Positive directional derivative for linesearch' case ( 9 ) message = 'More than max_iter iterations in slsqp' case default message = 'Unknown slsqp error' end select end function mode_to_status_message","tags":"","loc":"proc/mode_to_status_message.html"},{"title":"stop_iterations – slsqp","text":"private subroutine stop_iterations(me) A method that the user can call to stop the iterations.\n  (it can be called in any of the functions).\n  SLSQP will stop at the end of the next iteration. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me Contents Source Code stop_iterations Source Code subroutine stop_iterations ( me ) implicit none class ( slsqp_solver ), intent ( inout ) :: me me % user_triggered_stop = . true . end subroutine stop_iterations","tags":"","loc":"proc/stop_iterations.html"},{"title":"initialize_slsqp – slsqp","text":"private subroutine initialize_slsqp(me, n, m, meq, max_iter, acc, f, g, xl, xu, status_ok, linesearch_mode, iprint, report, alphamin, alphamax, gradient_mode, gradient_delta, tolf, toldf, toldx) initialize the slsqp_solver class.  see slsqp for more details. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: n the number of variables, integer, intent(in) :: m total number of constraints, integer, intent(in) :: meq number of equality constraints, integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: acc accuracy procedure( func ) :: f problem function procedure( grad ) :: g function to compute gradients (must be\n associated if gradient_mode=0 ) real(kind=wp), intent(in), dimension(n) :: xl lower bounds on x real(kind=wp), intent(in), dimension(n) :: xu upper bounds on x logical, intent(out) :: status_ok will be false if there were errors integer, intent(in), optional :: linesearch_mode 1 = inexact (default), 2 = exact integer, intent(in), optional :: iprint unit number of status messages (default=output_unit) procedure( iterfunc ), optional :: report user-defined procedure that will be called once per iteration real(kind=wp), intent(in), optional :: alphamin minimum alpha for linesearch [default 0.1] real(kind=wp), intent(in), optional :: alphamax maximum alpha for linesearch [default 1.0] integer, intent(in), optional :: gradient_mode how the gradients are to be computed: 0 - use the user-supplied g subroutine. [default] 1 - approximate by basic backward differences 2 - approximate by basic forward differences 3 - approximate by basic central differences real(kind=wp), intent(in), optional :: gradient_delta perturbation step size (>epsilon) to compute the approximated\n gradient by finite differences ( gradient_mode 1-3).\n note that this is an absolute step that does not respect\n the xl or xu variable bounds. real(kind=wp), intent(in), optional :: tolf stopping criterion if then stop. real(kind=wp), intent(in), optional :: toldf stopping criterion if then stop real(kind=wp), intent(in), optional :: toldx stopping criterion if then stop Contents Source Code initialize_slsqp Source Code subroutine initialize_slsqp ( me , n , m , meq , max_iter , acc , f , g , xl , xu , status_ok ,& linesearch_mode , iprint , report , alphamin , alphamax ,& gradient_mode , gradient_delta , tolf , toldf , toldx ) implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: n !! the number of variables,  n \\ge 1  integer , intent ( in ) :: m !! total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: max_iter !! maximum number of iterations procedure ( func ) :: f !! problem function procedure ( grad ) :: g !! function to compute gradients (must be !! associated if `gradient_mode=0`) real ( wp ), dimension ( n ), intent ( in ) :: xl !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xu !! upper bounds on `x` real ( wp ), intent ( in ) :: acc !! accuracy logical , intent ( out ) :: status_ok !! will be false if there were errors integer , intent ( in ), optional :: linesearch_mode !! 1 = inexact (default), 2 = exact integer , intent ( in ), optional :: iprint !! unit number of status messages (default=output_unit) procedure ( iterfunc ), optional :: report !! user-defined procedure that will be called once per iteration real ( wp ), intent ( in ), optional :: alphamin !! minimum alpha for linesearch [default 0.1] real ( wp ), intent ( in ), optional :: alphamax !! maximum alpha for linesearch [default 1.0] integer , intent ( in ), optional :: gradient_mode !! how the gradients are to be computed: !! !! * 0 - use the user-supplied `g` subroutine. [default] !! * 1 - approximate by basic backward differences !! * 2 - approximate by basic forward differences !! * 3 - approximate by basic central differences real ( wp ), intent ( in ), optional :: gradient_delta !! perturbation step size (>epsilon) to compute the approximated !! gradient by finite differences (`gradient_mode` 1-3). !! note that this is an absolute step that does not respect !! the `xl` or `xu` variable bounds. real ( wp ), intent ( in ), optional :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ), optional :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop real ( wp ), intent ( in ), optional :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop integer :: n1 , mineq , i status_ok = . false . call me % destroy () if ( present ( iprint )) me % iprint = iprint if ( size ( xl ) /= size ( xu ) . or . size ( xl ) /= n ) then call me % report_message ( 'error: invalid upper or lower bound vector size' ) call me % report_message ( '  size(xl) =' , ival = size ( xl )) call me % report_message ( '  size(xu) =' , ival = size ( xu )) call me % report_message ( '  n        =' , ival = n ) else if ( meq < 0 . or . meq > m ) then call me % report_message ( 'error: invalid meq value:' , ival = meq ) else if ( m < 0 ) then call me % report_message ( 'error: invalid m value:' , ival = m ) else if ( n < 1 ) then call me % report_message ( 'error: invalid n value:' , ival = n ) else if ( any ( xl > xu )) then call me % report_message ( 'error: lower bounds must be <= upper bounds.' ) do i = 1 , n if ( xl ( i ) > xu ( i )) then call me % report_message ( '  xl(i)>xu(i) for variable' , ival = i ) end if end do else if ( present ( linesearch_mode )) then !two linesearch modes: select case ( linesearch_mode ) case ( 1 ) !inexact me % linesearch_mode = linesearch_mode case ( 2 ) !exact me % linesearch_mode = linesearch_mode case default call me % report_message ( 'error: invalid linesearch_mode (must be 1 or 2): ' ,& ival = linesearch_mode ) call me % destroy () return end select end if !optional linesearch bounds: if ( present ( alphamin )) me % alphamin = alphamin if ( present ( alphamax )) me % alphamax = alphamax !verify valid values for alphamin and alphamax: 0<alphamin<alphamax<=1 if ( me % alphamin <= zero . or . me % alphamax <= zero . or . & me % alphamax <= me % alphamin . or . & me % alphamin >= one . or . me % alphamax > one ) then call me % report_message ( 'error: invalid values for alphamin or alphamax.' ) call me % report_message ( '  alphamin =' , rval = me % alphamin ) call me % report_message ( '  alphamax =' , rval = me % alphamax ) call me % destroy () return end if if ( present ( tolf )) me % tolf = tolf if ( present ( toldf )) me % toldf = toldf if ( present ( toldx )) me % toldx = toldx status_ok = . true . me % n = n me % m = m me % meq = meq me % max_iter = max_iter me % acc = acc me % f => f me % g => g if ( present ( report )) me % report => report allocate ( me % xl ( n )); me % xl = xl allocate ( me % xu ( n )); me % xu = xu !work arrays: n1 = n + 1 mineq = m - meq + 2 * n1 me % l_w = n1 * ( n1 + 1 ) + meq * ( n1 + 1 ) + mineq * ( n1 + 1 ) + & !for lsq ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + & !for lsi ( n1 + mineq ) * ( n1 - meq ) + 2 * meq + n1 + & !for lsei n1 * n / 2 + 2 * m + 3 * n + 3 * n1 + 1 !for slsqpb allocate ( me % w ( me % l_w )) me % w = zero if ( present ( gradient_mode )) then me % gradient_mode = gradient_mode if ( present ( gradient_delta )) then me % gradient_delta = gradient_delta end if end if end if end subroutine initialize_slsqp","tags":"","loc":"proc/initialize_slsqp.html"},{"title":"destroy_slsqp – slsqp","text":"private subroutine destroy_slsqp(me) destructor for slsqp_solver . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(out) :: me Contents Source Code destroy_slsqp Source Code subroutine destroy_slsqp ( me ) implicit none class ( slsqp_solver ), intent ( out ) :: me end subroutine destroy_slsqp","tags":"","loc":"proc/destroy_slsqp.html"},{"title":"slsqp_wrapper – slsqp","text":"private subroutine slsqp_wrapper(me, x, istat, iterations, status_message) main routine for calling slsqp . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x in: initial optimization variables, out: solution. integer, intent(out) :: istat status code (see mode in slsqp ). integer, intent(out), optional :: iterations number of iterations character(len=:), intent(out), optional allocatable :: status_message string status message\n corresponding to istat Calls proc~~slsqp_wrapper~~CallsGraph proc~slsqp_wrapper slsqp_wrapper proc~mode_to_status_message mode_to_status_message proc~slsqp_wrapper->proc~mode_to_status_message proc~slsqp slsqp proc~slsqp_wrapper->proc~slsqp proc~slsqpb slsqpb proc~slsqp->proc~slsqpb proc~dcopy dcopy proc~slsqpb->proc~dcopy proc~enforce_bounds enforce_bounds proc~slsqpb->proc~enforce_bounds proc~check_convergence check_convergence proc~slsqpb->proc~check_convergence proc~ldl ldl proc~slsqpb->proc~ldl proc~lsq lsq proc~slsqpb->proc~lsq proc~linmin linmin proc~slsqpb->proc~linmin proc~daxpy daxpy proc~slsqpb->proc~daxpy proc~ddot ddot proc~slsqpb->proc~ddot proc~dscal dscal proc~slsqpb->proc~dscal proc~dnrm2 dnrm2 proc~check_convergence->proc~dnrm2 proc~lsq->proc~dcopy proc~lsq->proc~enforce_bounds proc~lsq->proc~ddot proc~lsq->proc~dscal proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~dcopy proc~lsei->proc~ddot proc~lsei->proc~dnrm2 proc~lsi lsi proc~lsei->proc~lsi proc~h12 h12 proc~lsei->proc~h12 proc~hfti hfti proc~lsei->proc~hfti proc~lsi->proc~daxpy proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~dcopy proc~ldp->proc~daxpy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code slsqp_wrapper Source Code subroutine slsqp_wrapper ( me , x , istat , iterations , status_message ) implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x !! **in:**  initial optimization variables, !! **out:** solution. integer , intent ( out ) :: istat !! status code (see `mode` in [[slsqp]]). integer , intent ( out ), optional :: iterations !! number of iterations character ( len = :), intent ( out ), allocatable , optional :: status_message !! string status message !! corresponding to `istat` ! local variables: real ( wp ), dimension (:), allocatable :: c !! constraint vector -- `dimension(max(1,me%m))` real ( wp ), dimension (:,:), allocatable :: a !! a matrix for [[slsqp]] -- `dimension(max(1,me%m),me%n+1)` real ( wp ), dimension (:), allocatable :: g !! g matrix for [[slsqp]] -- `dimension(me%n+1)` real ( wp ), dimension (:), allocatable :: cvec !! constraint vector -- `dimension(me%m)` real ( wp ), dimension (:), allocatable :: dfdx !! objective function partials -- `dimension(me%n)` real ( wp ), dimension (:,:), allocatable :: dcdx !! constraint partials -- `dimension(me%m,me%n)` real ( wp ), dimension (:), allocatable :: delta !! perturbation step size to approximate gradient -- `dimension(me%n)` real ( wp ), dimension (:), allocatable :: cvecr !! right function value to approximate constraints vector's gradient -- `dimension(me%m)` real ( wp ), dimension (:), allocatable :: cvecl !! left function value to approximate constraints vector's gradient -- `dimension(me%m)` real ( wp ) :: f !! objective function integer :: i !! iteration counter integer :: mode !! reverse communication flag for [[slsqp]] integer :: la !! input to [[slsqp]] integer :: iter !! in/out for [[slsqp]] real ( wp ) :: acc !! in/out for [[slsqp]] integer :: ig !! loop index to approximate gradient real ( wp ) :: fr !! right function value to approximate objective function's gradient real ( wp ) :: fl !! left function value to approximate objective function's gradient real ( wp ) :: fact !! denominator factor for finite difference approximation !initialize: allocate ( c ( max ( 1 , me % m )) ) allocate ( a ( max ( 1 , me % m ), me % n + 1 )) allocate ( g ( me % n + 1 ) ) allocate ( cvec ( me % m ) ) allocate ( dfdx ( me % n ) ) allocate ( dcdx ( me % m , me % n ) ) allocate ( delta ( me % n ) ) allocate ( cvecr ( me % m ) ) allocate ( cvecl ( me % m ) ) i = 0 iter = me % max_iter la = max ( 1 , me % m ) mode = 0 a = zero g = zero c = zero if ( present ( iterations )) iterations = 0 call me % linmin % destroy () call me % slsqpb % destroy () !check setup: if ( size ( x ) /= me % n ) then istat = - 100 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !linesearch: select case ( me % linesearch_mode ) case ( 1 ) !inexact (armijo-type linesearch) acc = abs ( me % acc ) case ( 2 ) !exact acc = - abs ( me % acc ) case default istat = - 101 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end select !make sure the functions have been associated: if (. not . associated ( me % f )) then istat = - 102 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if (( me % gradient_mode == 0 ). and .(. not . associated ( me % g ))) then istat = - 103 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if ( me % gradient_mode < 0 . or . me % gradient_mode > 3 ) then istat = - 104 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if ( me % gradient_mode /= 0 . and . me % gradient_delta <= epmach ) then istat = - 105 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !main solver loop: do if ( mode == 0 . or . mode == 1 ) then !function evaluation (f&c) call me % f ( x , f , cvec ) c ( 1 : me % m ) = cvec end if if ( mode == 0 . or . mode ==- 1 ) then !gradient evaluation (g&a) select case ( me % gradient_mode ) case ( 0 ) ! user supplied gradients call me % g ( x , dfdx , dcdx ) g ( 1 : me % n ) = dfdx a ( 1 : me % m , 1 : me % n ) = dcdx case default ! approximate using finite differences if ( me % gradient_mode == 3 ) then fact = two ! central differences else fact = one ! forward/backward differences end if do ig = 1 , me % n !initialize a delta to perturb the objective !function and the constraint vector delta = zero delta ( ig ) = me % gradient_delta !get the right and left value of the objective !function and the constraint vector select case ( me % gradient_mode ) case ( 1 ) ! backward difference call me % f ( x , fr , cvecr ) call me % f ( x - delta , fl , cvecl ) case ( 2 ) ! forward difference call me % f ( x + delta , fr , cvecr ) call me % f ( x , fl , cvecl ) case ( 3 ) ! central difference call me % f ( x + delta , fr , cvecr ) call me % f ( x - delta , fl , cvecl ) end select !compute the gradients by first-order finite differences g ( ig ) = ( fr - fl ) / ( fact * delta ( ig ) ) if ( me % m > 0 ) then a (:, ig ) = ( cvecr - cvecl ) / ( fact * delta ( ig ) ) end if end do end select !this is an iteration: !note: the initial guess is reported as iteration 0: if ( associated ( me % report )) call me % report ( i , x , f , c ) !report iteration i = i + 1 ! iteration counter end if !main routine: call slsqp ( me % m , me % meq , la , me % n , x , me % xl , me % xu ,& f , c , g , a , acc , iter , mode ,& me % w , me % l_w ,& me % slsqpb , me % linmin , me % alphamin , me % alphamax ,& me % tolf , me % toldf , me % toldx ) if ( mode == 1 . or . mode ==- 1 ) then !continue to next call else if ( mode == 0 . and . associated ( me % report )) & call me % report ( i , x , f , c ) !report solution call me % report_message ( mode_to_status_message ( mode )) exit end if if ( me % user_triggered_stop ) then mode = - 2 call me % report_message ( mode_to_status_message ( mode )) me % user_triggered_stop = . false . !have to reset in case !method is called again. exit end if end do istat = mode if ( present ( iterations )) iterations = iter if ( present ( status_message )) status_message = mode_to_status_message ( istat ) end subroutine slsqp_wrapper","tags":"","loc":"proc/slsqp_wrapper.html"},{"title":"report_message – slsqp","text":"private subroutine report_message(me, str, ival, rval, fatal) Report a message from an slsqp_solver class. This uses the iprint variable in the class as the unit number for printing. Note: for fatal errors,\n  if no unit is specified, the error_unit is used. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(in) :: me character(len=*), intent(in) :: str the message to report. integer, intent(in), optional :: ival optional integer to print after the message. real(kind=wp), intent(in), optional :: rval optional real to print after the message. logical, intent(in), optional :: fatal if True, then the program is stopped (default=False). Contents Source Code report_message Source Code subroutine report_message ( me , str , ival , rval , fatal ) implicit none class ( slsqp_solver ), intent ( in ) :: me character ( len =* ), intent ( in ) :: str !! the message to report. integer , intent ( in ), optional :: ival !! optional integer to print after the message. real ( wp ), intent ( in ), optional :: rval !! optional real to print after the message. logical , intent ( in ), optional :: fatal !! if True, then the program is stopped (default=False). logical :: stop_program !! true if the program is to be stopped logical :: write_message !! true if the message is to be printed character ( len = 10 ) :: istr !! string version of `ival` character ( len = 30 ) :: rstr !! string version of `rval` character ( len = :), allocatable :: str_to_write !! the actual message to the printed integer :: istat !! iostat for integer to string conversion !fatal error check: if ( present ( fatal )) then stop_program = fatal else stop_program = . false . end if !note: if stopping program, then the message is always printed: write_message = me % iprint /= 0 . or . stop_program if ( write_message ) then if ( present ( ival )) then write ( istr , fmt = '(I10)' , iostat = istat ) ival if ( istat /= 0 ) istr = '*****' str_to_write = str // ' ' // trim ( adjustl ( istr )) elseif ( present ( rval )) then write ( istr , fmt = '(F30.16)' , iostat = istat ) rval if ( istat /= 0 ) rstr = '*****' str_to_write = str // ' ' // trim ( adjustl ( rstr )) else str_to_write = str end if if ( me % iprint == 0 ) then write ( error_unit , '(A)' ) str_to_write !in this case, use the error unit else write ( me % iprint , '(A)' ) str_to_write !user specified unit number end if deallocate ( str_to_write ) if ( stop_program ) error stop 'Fatal Error' end if end subroutine report_message","tags":"","loc":"proc/report_message.html"},{"title":"check_convergence – slsqp","text":"private function check_convergence(n, f, f0, x, x0, s, h3, acc, tolf, toldf, toldx, converged, not_converged) result(mode) Check for convergence. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: x0 real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in) :: h3 real(kind=wp), intent(in) :: acc real(kind=wp), intent(in) :: tolf real(kind=wp), intent(in) :: toldf real(kind=wp), intent(in) :: toldx integer, intent(in) :: converged mode value if converged integer, intent(in) :: not_converged mode value if not converged Return Value integer Calls proc~~check_convergence~~CallsGraph proc~check_convergence check_convergence proc~dnrm2 dnrm2 proc~check_convergence->proc~dnrm2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~check_convergence~~CalledByGraph proc~check_convergence check_convergence proc~slsqpb slsqpb proc~slsqpb->proc~check_convergence proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code check_convergence Source Code function check_convergence ( n , f , f0 , x , x0 , s , h3 , acc , tolf , toldf , toldx ,& converged , not_converged ) result ( mode ) implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: f real ( wp ), intent ( in ) :: f0 real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: x0 real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), intent ( in ) :: h3 real ( wp ), intent ( in ) :: acc real ( wp ), intent ( in ) :: tolf real ( wp ), intent ( in ) :: toldf real ( wp ), intent ( in ) :: toldx integer , intent ( in ) :: converged !! mode value if converged integer , intent ( in ) :: not_converged !! mode value if not converged integer :: mode logical :: ok ! temp variable real ( wp ), dimension ( n ) :: xmx0 if ( h3 < acc ) then mode = not_converged else ! if any are OK then it is converged ok = . false . if (. not . ok ) ok = abs ( f - f0 ) < acc if (. not . ok ) ok = dnrm2 ( n , s , 1 ) < acc ! note that these can be ignored if they are < 0: if (. not . ok . and . tolf >= zero ) ok = abs ( f ) < tolf if (. not . ok . and . toldf >= zero ) ok = abs ( f - f0 ) < toldf if (. not . ok . and . toldx >= zero ) then xmx0 = x - x0 ! to avoid array temporary warning ok = dnrm2 ( n , xmx0 , 1 ) < toldx end if if ( ok ) then mode = converged else mode = not_converged end if end if end function check_convergence","tags":"","loc":"proc/check_convergence.html"},{"title":"diff – slsqp","text":"private pure elemental function diff(u, v) result(d) Replaced statement function in the original code.\n  Returns . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: u real(kind=wp), intent(in) :: v Return Value real(kind=wp) Called by proc~~diff~~CalledByGraph proc~diff diff proc~hfti hfti proc~hfti->proc~diff proc~ldp ldp proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~diff proc~lsei lsei proc~lsei->proc~hfti proc~lsi lsi proc~lsei->proc~lsi proc~lsi->proc~ldp proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code diff Source Code pure elemental function diff ( u , v ) result ( d ) implicit none real ( wp ), intent ( in ) :: u real ( wp ), intent ( in ) :: v real ( wp ) :: d d = u - v end function diff","tags":"","loc":"proc/diff.html"},{"title":"linmin – slsqp","text":"private function linmin(mode, ax, bx, f, tol, a, b, d, e, p, q, r, u, v, w, x, m, fu, fv, fw, fx, tol1, tol2) Linesearch without derivatives (used by slsqp if linesearch_mode=2 ).\n  Returns the abscissa approximating the point where f attains a minimum. purpose: to find the argument linmin where the function f takes it's minimum\n  on the interval ax , bx . It uses a combination of golden section\n  and successive quadratic interpolation. Reference This function subprogram is a slightly modified version of the\n  ALGOL 60 procedure localmin given in R.P. Brent:\n  \" Algorithms for minimization without derivatives \",\n  Prentice-Hall (1973). History Kraft, D., DFVLR - institut fuer dynamik der flugsysteme\n    d-8031  oberpfaffenhofen status: 31. august 1984 Jacob Williams, Jan 2016, Refactored into modern Fortran.\n    Added saved variables as inout s to make the routine thread-safe. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: mode controls reverse communication\n must be set to 0 initially, returns with intermediate\n values 1 and 2 which must not be changed by the user,\n ends with convergence with value 3. real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp) :: f function value at linmin which is to be brought in by\n reverse communication controlled by mode real(kind=wp), intent(in) :: tol desired length of interval of uncertainty of final result real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(inout) :: d real(kind=wp), intent(inout) :: e real(kind=wp), intent(inout) :: p real(kind=wp), intent(inout) :: q real(kind=wp), intent(inout) :: r real(kind=wp), intent(inout) :: u real(kind=wp), intent(inout) :: v real(kind=wp), intent(inout) :: w real(kind=wp), intent(inout) :: x real(kind=wp), intent(inout) :: m real(kind=wp), intent(inout) :: fu real(kind=wp), intent(inout) :: fv real(kind=wp), intent(inout) :: fw real(kind=wp), intent(inout) :: fx real(kind=wp), intent(inout) :: tol1 real(kind=wp), intent(inout) :: tol2 Return Value real(kind=wp) Called by proc~~linmin~~CalledByGraph proc~linmin linmin proc~slsqpb slsqpb proc~slsqpb->proc~linmin proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code linmin Source Code real ( wp ) function linmin ( mode , ax , bx , f , tol ,& a , b , d , e , p , q , r , u , v ,& w , x , m , fu , fv , fw , fx , tol1 , tol2 ) implicit none integer , intent ( inout ) :: mode !! controls reverse communication !! must be set to 0 initially, returns with intermediate !! values 1 and 2 which must not be changed by the user, !! ends with convergence with value 3. real ( wp ) :: f !! function value at `linmin` which is to be brought in by !! reverse communication controlled by `mode` real ( wp ), intent ( in ) :: tol !! desired length of interval of uncertainty of final result real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( inout ) :: a , b , d , e , p , q , r , u , v , w , x , m , fu , fv , fw , fx , tol1 , tol2 real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! golden section ratio = `0.381966011` real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) !! square - root of machine precision select case ( mode ) case ( 1 ) ! main loop starts here fx = f fv = fx fw = fv case ( 2 ) fu = f ! update a, b, v, w, and x if ( fu > fx ) then if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . abs ( w - x ) <= zero ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . abs ( v - x ) <= zero . or . abs ( v - w ) <= zero ) then v = u fv = fu end if else if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu end if case default ! initialization a = ax b = bx e = zero v = a + c * ( b - a ) w = v x = w linmin = x mode = 1 return end select m = 0.5_wp * ( a + b ) tol1 = eps * abs ( x ) + tol tol2 = tol1 + tol1 ! test convergence if ( abs ( x - m ) <= tol2 - 0.5_wp * ( b - a ) ) then ! end of main loop linmin = x mode = 3 else r = zero q = r p = q if ( abs ( e ) > tol1 ) then ! fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = q - r q = q + q if ( q > zero ) p = - p if ( q < zero ) q = - q r = e e = d end if ! is parabola acceptable if ( abs ( p ) >= 0.5_wp * abs ( q * r ) . or . p <= q * ( a - x ) . or . p >= q * ( b - x ) ) then ! golden section step if ( x >= m ) e = a - x if ( x < m ) e = b - x d = c * e else ! parabolic interpolation step d = p / q ! f must not be evaluated too close to a or b if ( u - a < tol2 ) d = sign ( tol1 , m - x ) if ( b - u < tol2 ) d = sign ( tol1 , m - x ) end if ! f must not be evaluated too close to x if ( abs ( d ) < tol1 ) d = sign ( tol1 , d ) u = x + d linmin = u mode = 2 end if end function linmin","tags":"","loc":"proc/linmin.html"},{"title":"slsqp – slsqp","text":"public subroutine slsqp(m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, w, l_w, sdat, ldat, alphamin, alphamax, tolf, toldf, toldx) slsqp : s equential l east sq uares p rogramming\n  to solve general nonlinear optimization problems a nonlinear programming method with quadratic programming subproblems\n  this subroutine solves the general nonlinear programming problem: minimize subject to , , , the algorithm implements the method of Han and Powell\n  with BFGS-update of the b-matrix and L1-test function\n  within the steplength algorithm. Reference Dieter Kraft: \"A software package for sequential quadratic programming\",\n     DFVLR-FB 88-28, 1988 History implemented by: Dieter Kraft, DFVLR oberpfaffenhofen date: april - october, 1981. December, 31-st, 1984. March   , 21-st, 1987, revised to fortran 77 March   , 20-th, 1989, revised to ms-fortran April   , 14-th, 1989, hesse   in-line coded February, 28-th, 1991, fortran/2 version 1.04 accepts statement functions March   ,  1-st, 1991, tested with salford ftn77/386 compiler vers 2.40 in protected mode January ,        2016, Refactored into modern Fortran by Jacob Williams License Original version copyright 1991: Dieter Kraft, FHM.\n  Released under a BSD license. Note f , c , g , a must all be set by the user before each call. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m is the total number of constraints, integer, intent(in) :: meq is the number of equality constraints, integer, intent(in) :: la see a , integer, intent(in) :: n is the number of variables, real(kind=wp), intent(inout), dimension(n) :: x x() stores the current iterate of the n vector x on entry x() must be initialized. on exit x() stores the solution vector x if mode = 0 . real(kind=wp), intent(in), dimension(n) :: xl xl() stores an n vector of lower bounds xl to x . real(kind=wp), intent(in), dimension(n) :: xu xu() stores an n vector of upper bounds xu to x . real(kind=wp), intent(in) :: f is the value of the objective function. real(kind=wp), intent(in), dimension(la) :: c c() stores the m vector c of constraints,\n equality constraints (if any) first.\n dimension of c must be greater or equal la ,\n which must be greater or equal max(1,m) . real(kind=wp), intent(in), dimension(n+1) :: g g() stores the n vector g of partials of the\n objective function; dimension of g must be\n greater or equal n+1 . real(kind=wp), intent(in), dimension(la,n+1) :: a the la by n + 1 array a() stores\n the m by n matrix a of constraint normals. a() has first dimensioning parameter la ,\n which must be greater or equal max(1,m) . real(kind=wp), intent(inout) :: acc abs(acc) controls the final accuracy.\n if acc < zero an exact linesearch is performed,\n otherwise an armijo-type linesearch is used. integer, intent(inout) :: iter prescribes the maximum number of iterations.\n on exit iter indicates the number of iterations. integer, intent(inout) :: mode mode controls calculation: reverse communication is used in the sense that\n the program is initialized by mode = 0 ; then it is\n to be called repeatedly by the user until a return\n with mode /= abs(1) takes place.\n if mode = -1 gradients have to be calculated,\n while with mode = 1 functions have to be calculated.\n mode must not be changed between subsequent calls of slsqp . evaluation modes : -1 : gradient evaluation, ( g & a ) 0 : on entry : initialization, ( f , g , c , a ), on exit : required accuracy for solution obtained 1 : function evaluation, ( f & c ) failure modes : 2 : number of equality constraints larger than n 3 : more than 3*n iterations in lsq subproblem 4 : inequality constraints incompatible 5 : singular matrix e in lsq subproblem 6 : singular matrix c in lsq subproblem 7 : rank-deficient equality constraint subproblem hfti 8 : positive directional derivative for linesearch 9 : more than iter iterations in sqp >=10 : working space w too small, w should be enlarged to l_w=mode/1000 , real(kind=wp), intent(inout), dimension(l_w) :: w w() is a one dimensional working space.\n the first m+n+n*n1/2 elements of w must not be\n changed between subsequent calls of slsqp .\n on return w(1) ... w(m) contain the multipliers\n associated with the general constraints, while w(m+1) ... w(m+n(n+1)/2) store the cholesky factor l*d*l(t) of the approximate hessian of the\n lagrangian columnwise dense as lower triangular\n unit matrix l with d in its 'diagonal' and w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n) contain the multipliers associated with all\n constraints of the quadratic program finding\n the search direction to the solution x* integer, intent(in) :: l_w the length of w , which should be at least: (3*n1+m)*(n1+1) for lsq +(n1-meq+1)*(mineq+2) + 2*mineq for lsi +(n1+mineq)*(n1-meq) + 2*meq + n1 for lsei + n1*n/2 + 2*m + 3*n + 3*n1 + 1 for slsqpb with mineq = m - meq + 2*n1 & n1 = n+1 type( slsqpb_data ), intent(inout) :: sdat data for slsqpb . type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min for line search real(kind=wp), intent(in) :: alphamax max for line search real(kind=wp), intent(in) :: tolf stopping criterion if then stop. real(kind=wp), intent(in) :: toldf stopping criterion if then stop. real(kind=wp), intent(in) :: toldx stopping criterion if then stop. Calls proc~~slsqp~~CallsGraph proc~slsqp slsqp proc~slsqpb slsqpb proc~slsqp->proc~slsqpb proc~dcopy dcopy proc~slsqpb->proc~dcopy proc~enforce_bounds enforce_bounds proc~slsqpb->proc~enforce_bounds proc~check_convergence check_convergence proc~slsqpb->proc~check_convergence proc~ldl ldl proc~slsqpb->proc~ldl proc~lsq lsq proc~slsqpb->proc~lsq proc~linmin linmin proc~slsqpb->proc~linmin proc~daxpy daxpy proc~slsqpb->proc~daxpy proc~ddot ddot proc~slsqpb->proc~ddot proc~dscal dscal proc~slsqpb->proc~dscal proc~dnrm2 dnrm2 proc~check_convergence->proc~dnrm2 proc~lsq->proc~dcopy proc~lsq->proc~enforce_bounds proc~lsq->proc~ddot proc~lsq->proc~dscal proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~dcopy proc~lsei->proc~ddot proc~lsei->proc~dnrm2 proc~lsi lsi proc~lsei->proc~lsi proc~h12 h12 proc~lsei->proc~h12 proc~hfti hfti proc~lsei->proc~hfti proc~lsi->proc~daxpy proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~dcopy proc~ldp->proc~daxpy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~slsqp~~CalledByGraph proc~slsqp slsqp proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code slsqp Source Code subroutine slsqp ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode , w , l_w , & sdat , ldat , alphamin , alphamax , tolf , toldf , toldx ) implicit none integer , intent ( in ) :: m !! is the total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! is the number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: la !! see `a`,  la \\ge \\max(m,1)  integer , intent ( in ) :: n !! is the number of variables,  n \\ge 1  real ( wp ), dimension ( n ), intent ( inout ) :: x !! `x()` stores the current iterate of the `n` vector `x` !! on entry `x()` must be initialized. on exit `x()` !! stores the solution vector `x` if `mode = 0`. real ( wp ), dimension ( n ), intent ( in ) :: xl !! `xl()` stores an n vector of lower bounds `xl` to `x`. real ( wp ), dimension ( n ), intent ( in ) :: xu !! `xu()` stores an n vector of upper bounds `xu` to `x`. real ( wp ), intent ( in ) :: f !! is the value of the objective function. real ( wp ), dimension ( la ), intent ( in ) :: c !! `c()` stores the `m` vector `c` of constraints, !! equality constraints (if any) first. !! dimension of `c` must be greater or equal `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), dimension ( n + 1 ), intent ( in ) :: g !! `g()` stores the `n` vector `g` of partials of the !! objective function; dimension of `g` must be !! greater or equal `n+1`. real ( wp ), dimension ( la , n + 1 ), intent ( in ) :: a !! the `la` by `n + 1` array `a()` stores !! the `m` by `n` matrix `a` of constraint normals. !! `a()` has first dimensioning parameter `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), intent ( inout ) :: acc !! `abs(acc)` controls the final accuracy. !! if `acc` < zero an exact linesearch is performed, !! otherwise an armijo-type linesearch is used. integer , intent ( inout ) :: iter !! prescribes the maximum number of iterations. !! on exit `iter` indicates the number of iterations. integer , intent ( inout ) :: mode !! mode controls calculation: !! !! reverse communication is used in the sense that !! the program is initialized by `mode = 0`; then it is !! to be called repeatedly by the user until a return !! with `mode /= abs(1)` takes place. !! if `mode = -1` gradients have to be calculated, !! while with `mode = 1` functions have to be calculated. !! mode must not be changed between subsequent calls of [[slsqp]]. !! !! **evaluation modes**: !! !! * ** -1 **: gradient evaluation, (`g` & `a`) !! * **  0 **: *on entry*: initialization, (`f`, `g`, `c`, `a`), !!   *on exit*: required accuracy for solution obtained !! * **  1 **: function evaluation, (`f` & `c`) !! !! **failure modes**: !! !! * ** 2 **: number of equality constraints larger than `n` !! * ** 3 **: more than `3*n` iterations in [[lsq]] subproblem !! * ** 4 **: inequality constraints incompatible !! * ** 5 **: singular matrix `e` in [[lsq]] subproblem !! * ** 6 **: singular matrix `c` in [[lsq]] subproblem !! * ** 7 **: rank-deficient equality constraint subproblem [[hfti]] !! * ** 8 **: positive directional derivative for linesearch !! * ** 9 **: more than `iter` iterations in sqp !! * ** >=10 **: working space `w` too small, !!   `w` should be enlarged to `l_w=mode/1000`, integer , intent ( in ) :: l_w !! the length of `w`, which should be at least: !! !! * `(3*n1+m)*(n1+1)`                     **for lsq** !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`     **for lsi** !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`   **for lsei** !! * `+ n1*n/2 + 2*m + 3*n + 3*n1 + 1`     **for slsqpb** !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` real ( wp ), dimension ( l_w ), intent ( inout ) :: w !! `w()` is a one dimensional working space. !! the first `m+n+n*n1/2` elements of `w` must not be !! changed between subsequent calls of [[slsqp]]. !! on return `w(1) ... w(m)` contain the multipliers !! associated with the general constraints, while !! `w(m+1) ... w(m+n(n+1)/2)` store the cholesky factor !! `l*d*l(t)` of the approximate hessian of the !! lagrangian columnwise dense as lower triangular !! unit matrix `l` with `d` in its 'diagonal' and !! `w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n)` !! contain the multipliers associated with all !! constraints of the quadratic program finding !! the search direction to the solution `x*` type ( slsqpb_data ), intent ( inout ) :: sdat !! data for [[slsqpb]]. type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ) :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop. real ( wp ), intent ( in ) :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop. integer :: il , im , ir , is , iu , iv , iw , ix , mineq , n1 !   check length of working arrays n1 = n + 1 mineq = m - meq + n1 + n1 il = ( 3 * n1 + m ) * ( n1 + 1 ) + ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + ( n1 + mineq )& * ( n1 - meq ) + 2 * meq + n1 * n / 2 + 2 * m + 3 * n + 4 * n1 + 1 im = max ( mineq , n1 - meq ) if ( l_w < il ) then mode = 1000 * max ( 10 , il ) mode = mode + max ( 10 , im ) iter = 0 return end if if ( meq > n ) then ! note: calling lsq when meq>n is corrupting the ! memory in some way, so just catch this here. mode = 2 iter = 0 return end if !   prepare data for calling sqpbdy  -  initial addresses in w im = 1 il = im + max ( 1 , m ) il = im + la ix = il + n1 * n / 2 + 1 ir = ix + n is = ir + n + n + max ( 1 , m ) is = ir + n + n + la iu = is + n1 iv = iu + n1 iw = iv + n1 sdat % n1 = n1 call slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& w ( ir ), w ( il ), w ( ix ), w ( im ), w ( is ), w ( iu ), w ( iv ), w ( iw ),& sdat % t , sdat % f0 , sdat % h1 , sdat % h2 , sdat % h3 , sdat % h4 ,& sdat % n1 , sdat % n2 , sdat % n3 , sdat % t0 , sdat % gs , sdat % tol , sdat % line ,& sdat % alpha , sdat % iexact , sdat % incons , sdat % ireset , sdat % itermx ,& ldat , alphamin , alphamax , tolf , toldf , toldx ) end subroutine slsqp","tags":"","loc":"proc/slsqp.html"},{"title":"slsqpb – slsqp","text":"private subroutine slsqpb(m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, r, l, x0, mu, s, u, v, w, t, f0, h1, h2, h3, h4, n1, n2, n3, t0, gs, tol, line, alpha, iexact, incons, ireset, itermx, ldat, alphamin, alphamax, tolf, toldf, toldx) nonlinear programming by solving sequentially quadratic programs l1 - line search, positive definite bfgs update Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: la integer, intent(in) :: n real(kind=wp), dimension(n) :: x real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp) :: f real(kind=wp), dimension(la) :: c real(kind=wp), dimension(n+1) :: g real(kind=wp), dimension(la,n+1) :: a real(kind=wp) :: acc integer, intent(inout) :: iter in: maximum number of iterations. out: actual number of iterations. integer, intent(inout) :: mode real(kind=wp), dimension(m+n+n+2) :: r real(kind=wp), dimension((n+1)*(n+2)/2) :: l real(kind=wp), dimension(n) :: x0 real(kind=wp), dimension(la) :: mu real(kind=wp), dimension(n+1) :: s real(kind=wp), dimension(n+1) :: u real(kind=wp), dimension(n+1) :: v real(kind=wp), intent(inout), dimension(*) :: w dim(w) = n1*(n1+1) + meq*(n1+1) + mineq*(n1+1) for lsq +(n1-meq+1)*(mineq+2) + 2*mineq for lsi +(n1+mineq)*(n1-meq) + 2*meq + n1 for lsei with mineq = m - meq + 2*n1 & n1 = n+1 real(kind=wp), intent(inout) :: t real(kind=wp), intent(inout) :: f0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(inout) :: h2 real(kind=wp), intent(inout) :: h3 real(kind=wp), intent(inout) :: h4 integer, intent(inout) :: n1 integer, intent(inout) :: n2 integer, intent(inout) :: n3 real(kind=wp), intent(inout) :: t0 real(kind=wp), intent(inout) :: gs real(kind=wp), intent(inout) :: tol integer, intent(inout) :: line real(kind=wp), intent(inout) :: alpha integer, intent(inout) :: iexact integer, intent(inout) :: incons integer, intent(inout) :: ireset integer, intent(inout) :: itermx type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min for line search real(kind=wp), intent(in) :: alphamax max for line search real(kind=wp), intent(in) :: tolf stopping criterion if then stop. real(kind=wp), intent(in) :: toldf stopping criterion if then stop real(kind=wp), intent(in) :: toldx stopping criterion if then stop Calls proc~~slsqpb~~CallsGraph proc~slsqpb slsqpb proc~dcopy dcopy proc~slsqpb->proc~dcopy proc~enforce_bounds enforce_bounds proc~slsqpb->proc~enforce_bounds proc~check_convergence check_convergence proc~slsqpb->proc~check_convergence proc~ldl ldl proc~slsqpb->proc~ldl proc~lsq lsq proc~slsqpb->proc~lsq proc~linmin linmin proc~slsqpb->proc~linmin proc~daxpy daxpy proc~slsqpb->proc~daxpy proc~ddot ddot proc~slsqpb->proc~ddot proc~dscal dscal proc~slsqpb->proc~dscal proc~dnrm2 dnrm2 proc~check_convergence->proc~dnrm2 proc~lsq->proc~dcopy proc~lsq->proc~enforce_bounds proc~lsq->proc~ddot proc~lsq->proc~dscal proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~dcopy proc~lsei->proc~ddot proc~lsei->proc~dnrm2 proc~lsi lsi proc~lsei->proc~lsi proc~h12 h12 proc~lsei->proc~h12 proc~hfti hfti proc~lsei->proc~hfti proc~lsi->proc~daxpy proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~dcopy proc~ldp->proc~daxpy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~slsqpb~~CalledByGraph proc~slsqpb slsqpb proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code slsqpb Source Code subroutine slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& r , l , x0 , mu , s , u , v , w ,& t , f0 , h1 , h2 , h3 , h4 , n1 , n2 , n3 , t0 , gs , tol , line ,& alpha , iexact , incons , ireset , itermx , ldat ,& alphamin , alphamax , tolf , toldf , toldx ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: meq integer , intent ( in ) :: la integer , intent ( in ) :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: f real ( wp ), dimension ( la ) :: c real ( wp ), dimension ( n + 1 ) :: g real ( wp ), dimension ( la , n + 1 ) :: a real ( wp ) :: acc integer , intent ( inout ) :: iter !! **in:**  maximum number of iterations. !! **out:** actual number of iterations. integer , intent ( inout ) :: mode real ( wp ), dimension ( m + n + n + 2 ) :: r real ( wp ), dimension (( n + 1 ) * ( n + 2 ) / 2 ) :: l real ( wp ), dimension ( n ) :: x0 real ( wp ), dimension ( la ) :: mu real ( wp ), dimension ( n + 1 ) :: s real ( wp ), dimension ( n + 1 ) :: u real ( wp ), dimension ( n + 1 ) :: v real ( wp ), dimension ( * ), intent ( inout ) :: w !! `dim(w)` = !! !! * `n1*(n1+1) + meq*(n1+1) + mineq*(n1+1)`   for [[lsq]] !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`         for [[lsi]] !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`       for [[lsei]] !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` real ( wp ), intent ( inout ) :: t real ( wp ), intent ( inout ) :: f0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( inout ) :: h2 real ( wp ), intent ( inout ) :: h3 real ( wp ), intent ( inout ) :: h4 integer , intent ( inout ) :: n1 integer , intent ( inout ) :: n2 integer , intent ( inout ) :: n3 real ( wp ), intent ( inout ) :: t0 real ( wp ), intent ( inout ) :: gs real ( wp ), intent ( inout ) :: tol integer , intent ( inout ) :: line real ( wp ), intent ( inout ) :: alpha integer , intent ( inout ) :: iexact integer , intent ( inout ) :: incons integer , intent ( inout ) :: ireset integer , intent ( inout ) :: itermx type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ) :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop real ( wp ), intent ( in ) :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop integer :: i , j , k if ( mode < 0 ) then ! call jacobian at current x ! update cholesky-factors of hessian matrix by modified bfgs formula do i = 1 , n u ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) - v ( i ) end do ! l'*s k = 0 do i = 1 , n h1 = zero k = k + 1 do j = i + 1 , n k = k + 1 h1 = h1 + l ( k ) * s ( j ) end do v ( i ) = s ( i ) + h1 end do ! d*l'*s k = 1 do i = 1 , n v ( i ) = l ( k ) * v ( i ) k = k + n1 - i end do ! l*d*l'*s do i = n , 1 , - 1 h1 = zero k = i do j = 1 , i - 1 h1 = h1 + l ( k ) * v ( j ) k = k + n - j end do v ( i ) = v ( i ) + h1 end do h1 = ddot ( n , s , 1 , u , 1 ) h2 = ddot ( n , s , 1 , v , 1 ) h3 = 0.2_wp * h2 if ( h1 < h3 ) then h4 = ( h2 - h3 ) / ( h2 - h1 ) h1 = h3 call dscal ( n , h4 , u , 1 ) call daxpy ( n , one - h4 , v , 1 , u , 1 ) end if call ldl ( n , l , u , + one / h1 , v ) call ldl ( n , l , v , - one / h2 , u ) ! end of main iteration goto 200 else if ( mode == 0 ) then itermx = iter if ( acc >= zero ) then iexact = 0 else iexact = 1 end if acc = abs ( acc ) tol = ten * acc iter = 0 ireset = 0 n1 = n + 1 n2 = n1 * n / 2 n3 = n2 + 1 s ( 1 ) = zero mu ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) call dcopy ( m , mu ( 1 ), 0 , mu , 1 ) else ! call functions at current x t = f do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if t = t + mu ( j ) * max ( - c ( j ), h1 ) end do h1 = t - t0 if ( iexact + 1 == 1 ) then if ( h1 <= h3 / ten . or . line > 10 ) goto 500 alpha = min ( max ( h3 / ( two * ( h3 - h1 )), alphamin ), alphamax ) goto 300 else if ( iexact + 1 == 2 ) then goto 400 else goto 500 end if end if ! reset bfgs matrix 100 ireset = ireset + 1 if ( ireset > 5 ) then ! check relaxed convergence in case of positive directional derivative mode = check_convergence ( n , f , f0 , x , x0 , s , h3 , tol , tolf , toldf , toldx , 0 , 8 ) return else l ( 1 ) = zero call dcopy ( n2 , l ( 1 ), 0 , l , 1 ) j = 1 do i = 1 , n l ( j ) = one j = j + n1 - i end do end if ! main iteration : search direction, steplength, ldl'-update 200 iter = iter + 1 mode = 9 if ( iter > itermx ) return ! search direction as solution of qp - subproblem call dcopy ( n , xl , 1 , u , 1 ) call dcopy ( n , xu , 1 , v , 1 ) call daxpy ( n , - one , x , 1 , u , 1 ) call daxpy ( n , - one , x , 1 , v , 1 ) h4 = one call lsq ( m , meq , n , n3 , la , l , g , a , c , u , v , s , r , w , mode ) ! augmented problem for inconsistent linearization if ( mode == 6 ) then if ( n == meq ) mode = 4 end if if ( mode == 4 ) then do j = 1 , m if ( j <= meq ) then a ( j , n1 ) = - c ( j ) else a ( j , n1 ) = max ( - c ( j ), zero ) end if end do s ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) h3 = zero g ( n1 ) = zero l ( n3 ) = hun s ( n1 ) = one u ( n1 ) = zero v ( n1 ) = one incons = 0 250 call lsq ( m , meq , n1 , n3 , la , l , g , a , c , u , v , s , r , w , mode ) h4 = one - s ( n1 ) if ( mode == 4 ) then l ( n3 ) = ten * l ( n3 ) incons = incons + 1 if ( incons <= 5 ) goto 250 return else if ( mode /= 1 ) then return end if else if ( mode /= 1 ) then return end if ! update multipliers for l1-test do i = 1 , n v ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) end do f0 = f call dcopy ( n , x , 1 , x0 , 1 ) gs = ddot ( n , g , 1 , s , 1 ) h1 = abs ( gs ) h2 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h2 = h2 + max ( - c ( j ), h3 ) h3 = abs ( r ( j )) mu ( j ) = max ( h3 ,( mu ( j ) + h3 ) / two ) h1 = h1 + h3 * abs ( c ( j )) end do ! check convergence mode = 0 if ( h1 < acc . and . h2 < acc ) return h1 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h1 = h1 + mu ( j ) * max ( - c ( j ), h3 ) end do t0 = f + h1 h3 = gs - h1 * h4 mode = 8 if ( h3 >= zero ) goto 100 ! line search with an l1-testfunction line = 0 alpha = alphamax if ( iexact == 1 ) goto 400 ! inexact linesearch 300 line = line + 1 h3 = alpha * h3 call dscal ( n , alpha , s , 1 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , one , s , 1 , x , 1 ) call enforce_bounds ( x , xl , xu ) ! ensure that x doesn't violate bounds mode = 1 return ! exact linesearch 400 if ( line /= 3 ) then alpha = linmin ( line , alphamin , alphamax , t , tol , & ldat % a , ldat % b , ldat % d , ldat % e , ldat % p , ldat % q , & ldat % r , ldat % u , ldat % v , ldat % w , ldat % x , ldat % m , & ldat % fu , ldat % fv , ldat % fw , ldat % fx , ldat % tol1 , ldat % tol2 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , alpha , s , 1 , x , 1 ) mode = 1 return end if call dscal ( n , alpha , s , 1 ) ! check convergence 500 h3 = zero do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if h3 = h3 + max ( - c ( j ), h1 ) end do mode = check_convergence ( n , f , f0 , x , x0 , s , h3 , acc , tolf , toldf , toldx , 0 , - 1 ) end subroutine slsqpb","tags":"","loc":"proc/slsqpb.html"},{"title":"lsq – slsqp","text":"private subroutine lsq(m, meq, n, nl, la, l, g, a, b, xl, xu, x, y, w, mode) Minimize with respect to ,\n  with upper triangular matrix ,\n  and vector ,\n  where the unit lower tridiangular matrix is stored columnwise\n  dense in the array with vector stored in its\n  'diagonal' thus substituting the one-elements of subject to: , , , On entry, the user has to provide the arrays l , g , a , b , xl , xu .\n  with dimensions: l(n*(n+1)/2) , g(n) , a(la,n) , b(m) , xl(n) , xu(n) . The working array w must have at least the following dimension: dim(w) = (3*n+m)*(n+1) for lsq +(n-meq+1)*(mineq+2) + 2*mineq for lsi +(n+mineq)*(n-meq) + 2*meq + n for lsei with mineq = m - meq + 2*n On return, no array will be changed by the subroutine. History coded dieter kraft, april 1987 revised march 1989 Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: n integer, intent(in) :: nl integer, intent(in) :: la real(kind=wp), dimension(nl) :: l real(kind=wp), dimension(n) :: g real(kind=wp), dimension(la,n) :: a real(kind=wp), dimension(la) :: b real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp), dimension(n) :: x stores the n-dimensional solution vector real(kind=wp), dimension(m+n+n) :: y stores the vector of lagrange multipliers of dimension\n m+n+n (constraints+lower+upper bounds) real(kind=wp), dimension(*) :: w integer :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank, 6: matrix c is not of full rank, 7: rank defect in hfti Calls proc~~lsq~~CallsGraph proc~lsq lsq proc~dcopy dcopy proc~lsq->proc~dcopy proc~enforce_bounds enforce_bounds proc~lsq->proc~enforce_bounds proc~ddot ddot proc~lsq->proc~ddot proc~lsei lsei proc~lsq->proc~lsei proc~dscal dscal proc~lsq->proc~dscal proc~lsei->proc~dcopy proc~lsei->proc~ddot proc~lsi lsi proc~lsei->proc~lsi proc~h12 h12 proc~lsei->proc~h12 proc~dnrm2 dnrm2 proc~lsei->proc~dnrm2 proc~hfti hfti proc~lsei->proc~hfti proc~lsi->proc~ddot proc~lsi->proc~h12 proc~lsi->proc~dnrm2 proc~daxpy daxpy proc~lsi->proc~daxpy proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~dcopy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~daxpy proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lsq~~CalledByGraph proc~lsq lsq proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lsq Source Code subroutine lsq ( m , meq , n , nl , la , l , g , a , b , xl , xu , x , y , w , mode ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: meq integer , intent ( in ) :: nl integer , intent ( in ) :: la real ( wp ), dimension ( n ) :: x !! stores the n-dimensional solution vector real ( wp ), dimension ( m + n + n ) :: y !! stores the vector of lagrange multipliers of dimension !! m+n+n (constraints+lower+upper bounds) integer :: mode !! is a success-failure flag with the following meanings: !! !! * **1:** successful computation, !! * **2:** error return because of wrong dimensions (`n<1`), !! * **3:** iteration count exceeded by [[nnls]], !! * **4:** inequality constraints incompatible, !! * **5:** matrix `e` is not of full rank, !! * **6:** matrix `c` is not of full rank, !! * **7:** rank defect in [[hfti]] real ( wp ), dimension ( nl ) :: l real ( wp ), dimension ( n ) :: g real ( wp ), dimension ( la , n ) :: a real ( wp ), dimension ( la ) :: b real ( wp ), dimension ( * ) :: w real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: diag , xnorm integer :: i , ic , id , ie , if , ig , ih , il , im , ip , & iu , iw , i1 , i2 , i3 , i4 , mineq , & m1 , n1 , n2 , n3 n1 = n + 1 mineq = m - meq m1 = mineq + n + n !  determine whether to solve problem !  with inconsistent linerarization (n2=1) !  or not (n2=0) n2 = n1 * n / 2 + 1 if ( n2 == nl ) then n2 = 0 else n2 = 1 end if n3 = n - n2 !  recover matrix e and vector f from l and g i2 = 1 i3 = 1 i4 = 1 ie = 1 if = n * n + 1 do i = 1 , n3 i1 = n1 - i diag = sqrt ( l ( i2 )) w ( i3 ) = zero call dcopy ( i1 , w ( i3 ), 0 , w ( i3 ), 1 ) call dcopy ( i1 - n2 , l ( i2 ), 1 , w ( i3 ), n ) call dscal ( i1 - n2 , diag , w ( i3 ), n ) w ( i3 ) = diag w ( if - 1 + i ) = ( g ( i ) - ddot ( i - 1 , w ( i4 ), 1 , w ( if ), 1 )) / diag i2 = i2 + i1 - n2 i3 = i3 + n1 i4 = i4 + n end do if ( n2 == 1 ) then w ( i3 ) = l ( nl ) w ( i4 ) = zero call dcopy ( n3 , w ( i4 ), 0 , w ( i4 ), 1 ) w ( if - 1 + n ) = zero end if call dscal ( n , - one , w ( if ), 1 ) ic = if + n id = ic + meq * n if ( meq > 0 ) then !  recover matrix c from upper part of a do i = 1 , meq call dcopy ( n , a ( i , 1 ), la , w ( ic - 1 + i ), meq ) end do !  recover vector d from upper part of b call dcopy ( meq , b ( 1 ), 1 , w ( id ), 1 ) call dscal ( meq , - one , w ( id ), 1 ) end if ig = id + meq if ( mineq > 0 ) then !  recover matrix g from lower part of a do i = 1 , mineq call dcopy ( n , a ( meq + i , 1 ), la , w ( ig - 1 + i ), m1 ) end do end if !  augment matrix g by +i and -i ip = ig + mineq do i = 1 , n w ( ip - 1 + i ) = zero call dcopy ( n , w ( ip - 1 + i ), 0 , w ( ip - 1 + i ), m1 ) end do w ( ip ) = one call dcopy ( n , w ( ip ), 0 , w ( ip ), m1 + 1 ) im = ip + n do i = 1 , n w ( im - 1 + i ) = zero call dcopy ( n , w ( im - 1 + i ), 0 , w ( im - 1 + i ), m1 ) end do w ( im ) = - one call dcopy ( n , w ( im ), 0 , w ( im ), m1 + 1 ) ih = ig + m1 * n if ( mineq > 0 ) then ! recover h from lower part of b call dcopy ( mineq , b ( meq + 1 ), 1 , w ( ih ), 1 ) call dscal ( mineq , - one , w ( ih ), 1 ) end if !  augment vector h by xl and xu il = ih + mineq call dcopy ( n , xl , 1 , w ( il ), 1 ) iu = il + n call dcopy ( n , xu , 1 , w ( iu ), 1 ) call dscal ( n , - one , w ( iu ), 1 ) iw = iu + n call lsei ( w ( ic ), w ( id ), w ( ie ), w ( if ), w ( ig ), w ( ih ), max ( 1 , meq ), meq , n , n , & m1 , m1 , n , x , xnorm , w ( iw ), mode ) if ( mode == 1 ) then ! restore lagrange multipliers call dcopy ( m , w ( iw ), 1 , y ( 1 ), 1 ) call dcopy ( n3 , w ( iw + m ), 1 , y ( m + 1 ), 1 ) call dcopy ( n3 , w ( iw + m + n ), 1 , y ( m + n3 + 1 ), 1 ) call enforce_bounds ( x , xl , xu ) ! to ensure that bounds are not violated end if end subroutine lsq","tags":"","loc":"proc/lsq.html"},{"title":"lsei – slsqp","text":"private subroutine lsei(c, d, e, f, g, h, lc, mc, le, me, lg, mg, n, x, xnrm, w, mode) for mode=1 , the subroutine returns the solution x of\n  equality & inequality constrained least squares problem lsei : s.t. and . using QR decomposition & orthogonal basis of nullspace of . The following dimensions of the arrays defining the problem\n  are necessary: dim ( c ) : formal ( lc , n ) , actual ( mc , n ) dim ( d ) : formal ( lc ) , actual ( mc ) dim ( e ) : formal ( le , n ) , actual ( me , n ) dim ( f ) : formal ( le ) , actual ( me ) dim ( g ) : formal ( lg , n ) , actual ( mg , n ) dim ( h ) : formal ( lg ) , actual ( mg ) dim ( x ) : formal ( n ) , actual ( n ) dim ( w ) : 2 * mc + me + ( me + mg ) * ( n - mc ) for lsei + ( n - mc + 1 ) * ( mg + 2 ) + 2 * mg for lsi dim ( jw ) : max ( mg , l ) On entry, the user has to provide the arrays C, d, E, f, G, and h.\n  On return, all arrays will be changed by the subroutine. Reference Chapter 23.6 of Lawson & Hanson: Solving least squares problems. History 18.5.1981, dieter kraft, dfvlr oberpfaffenhofen 20.3.1987, dieter kraft, dfvlr oberpfaffenhofen Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(lc,n) :: c real(kind=wp), intent(inout), dimension(lc) :: d real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: lc integer, intent(in) :: mc integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnrm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w on return, stores the vector of lagrange multipliers\n in its first mc+mg elements integer, intent(out) :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank, 6: matrix c is not of full rank, 7: rank defect in hfti Calls proc~~lsei~~CallsGraph proc~lsei lsei proc~dcopy dcopy proc~lsei->proc~dcopy proc~h12 h12 proc~lsei->proc~h12 proc~lsi lsi proc~lsei->proc~lsi proc~ddot ddot proc~lsei->proc~ddot proc~hfti hfti proc~lsei->proc~hfti proc~dnrm2 dnrm2 proc~lsei->proc~dnrm2 proc~lsi->proc~h12 proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~daxpy daxpy proc~lsi->proc~daxpy proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~dcopy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~daxpy proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lsei~~CalledByGraph proc~lsei lsei proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lsei Source Code subroutine lsei ( c , d , e , f , g , h , lc , mc , le , me , lg , mg , n , x , xnrm , w , mode ) implicit none integer , intent ( in ) :: lc integer , intent ( in ) :: mc integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( lc , n ), intent ( inout ) :: c real ( wp ), dimension ( lc ) , intent ( inout ) :: d real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnrm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! on return, stores the vector of lagrange multipliers !! in its first `mc+mg` elements integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank, !! * ***6:*** matrix `c` is not of full rank, !! * ***7:*** rank defect in [[hfti]] integer :: i , ie , if , ig , iw , j , k , krank , l , mc1 real ( wp ) :: t , dum ( 1 ) mode = 2 if ( mc <= n ) then l = n - mc mc1 = mc + 1 iw = ( l + 1 ) * ( mg + 2 ) + 2 * mg + mc ie = iw + mc + 1 if = ie + me * l ig = if + me !  triangularize c and apply factors to e and g do i = 1 , mc j = min ( i + 1 , lc ) call h12 ( 1 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), c ( j , 1 ), lc , 1 , mc - i ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), e , le , 1 , me ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), g , lg , 1 , mg ) end do !  solve c*x=d and modify f mode = 6 do i = 1 , mc if ( abs ( c ( i , i )) < epmach ) return x ( i ) = ( d ( i ) - ddot ( i - 1 , c ( i , 1 ), lc , x , 1 )) / c ( i , i ) end do mode = 1 w ( mc1 ) = zero !call dcopy(mg-mc,w(mc1),0,w(mc1),1)  ! original code call dcopy ( mg , w ( mc1 ), 0 , w ( mc1 ), 1 ) ! bug fix for when meq = n if ( mc /= n ) then do i = 1 , me w ( if - 1 + i ) = f ( i ) - ddot ( mc , e ( i , 1 ), le , x , 1 ) end do !  store transformed e & g do i = 1 , me call dcopy ( l , e ( i , mc1 ), le , w ( ie - 1 + i ), me ) end do do i = 1 , mg call dcopy ( l , g ( i , mc1 ), lg , w ( ig - 1 + i ), mg ) end do if ( mg > 0 ) then !  modify h and solve inequality constrained ls problem do i = 1 , mg h ( i ) = h ( i ) - ddot ( mc , g ( i , 1 ), lg , x , 1 ) end do call lsi ( w ( ie ), w ( if ), w ( ig ), h , me , me , mg , mg , l , x ( mc1 ), xnrm , & w ( mc1 ), mode ) if ( mc == 0 ) return t = dnrm2 ( mc , x , 1 ) xnrm = sqrt ( xnrm * xnrm + t * t ) if ( mode /= 1 ) return else ! solve ls without inequality constraints mode = 7 k = max ( le , n ) t = sqrt ( epmach ) call hfti ( w ( ie ), me , me , l , w ( if ), k , 1 , t , krank , dum , w , w ( l + 1 )) xnrm = dum ( 1 ) call dcopy ( l , w ( if ), 1 , x ( mc1 ), 1 ) if ( krank /= l ) return mode = 1 end if end if !  solution of original problem and lagrange multipliers do i = 1 , me f ( i ) = ddot ( n , e ( i , 1 ), le , x , 1 ) - f ( i ) end do do i = 1 , mc d ( i ) = ddot ( me , e ( 1 , i ), 1 , f , 1 ) & - ddot ( mg , g ( 1 , i ), 1 , w ( mc1 ), 1 ) end do do i = mc , 1 , - 1 call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), x , 1 , 1 , 1 ) end do do i = mc , 1 , - 1 j = min ( i + 1 , lc ) w ( i ) = ( d ( i ) - ddot ( mc - i , c ( j , i ), 1 , w ( j ), 1 )) / c ( i , i ) end do end if end subroutine lsei","tags":"","loc":"proc/lsei.html"},{"title":"lsi – slsqp","text":"private subroutine lsi(e, f, g, h, le, me, lg, mg, n, x, xnorm, w, mode) for mode=1 , the subroutine returns the solution x of\n  inequality constrained linear least squares problem: s.t. . the following dimensions of the arrays defining the problem\n  are necessary: dim(e) :   formal (le,n),    actual (me,n)\n     dim(f) :   formal (le  ),    actual (me  )\n     dim(g) :   formal (lg,n),    actual (mg,n)\n     dim(h) :   formal (lg  ),    actual (mg  )\n     dim(x) :   n\n     dim(w) :   (n+1)*(mg+2) + 2*mg\n     dim(jw):   lg on entry, the user has to provide the arrays e , f , g , and h .\n  on return, all arrays will be changed by the subroutine. Reference Chapter 23.6 of Lawson & Hanson: Solving least squares problems. History 03.01.1980, dieter kraft: coded 20.03.1987, dieter kraft: revised to fortran 77 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnorm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w stores the vector of lagrange multipliers in its first mg elements integer, intent(out) :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank. Calls proc~~lsi~~CallsGraph proc~lsi lsi proc~h12 h12 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~daxpy daxpy proc~lsi->proc~daxpy proc~ddot ddot proc~lsi->proc~ddot proc~dnrm2 dnrm2 proc~lsi->proc~dnrm2 proc~ldp->proc~daxpy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~dcopy dcopy proc~ldp->proc~dcopy proc~diff diff proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lsi~~CalledByGraph proc~lsi lsi proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lsi Source Code subroutine lsi ( e , f , g , h , le , me , lg , mg , n , x , xnorm , w , mode ) implicit none integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnorm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! stores the vector of lagrange multipliers in its first !! `mg` elements integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank. integer :: i , j real ( wp ) :: t !  qr-factors of e and application to f do i = 1 , n j = min ( i + 1 , n ) call h12 ( 1 , i , i + 1 , me , e ( 1 , i ), 1 , t , e ( 1 , j ), 1 , le , n - i ) call h12 ( 2 , i , i + 1 , me , e ( 1 , i ), 1 , t , f , 1 , 1 , 1 ) end do !  transform g and h to get least distance problem mode = 5 do i = 1 , mg do j = 1 , n if ( abs ( e ( j , j )) < epmach ) return g ( i , j ) = ( g ( i , j ) - ddot ( j - 1 , g ( i , 1 ), lg , e ( 1 , j ), 1 )) / e ( j , j ) end do h ( i ) = h ( i ) - ddot ( n , g ( i , 1 ), lg , f , 1 ) end do !  solve least distance problem call ldp ( g , lg , mg , n , h , x , xnorm , w , mode ) if ( mode == 1 ) then !  solution of original problem call daxpy ( n , one , f , 1 , x , 1 ) do i = n , 1 , - 1 j = min ( i + 1 , n ) x ( i ) = ( x ( i ) - ddot ( n - i , e ( i , j ), le , x ( j ), 1 )) / e ( i , i ) end do j = min ( n + 1 , me ) t = dnrm2 ( me - n , f ( j ), 1 ) xnorm = sqrt ( xnorm * xnorm + t * t ) end if end subroutine lsi","tags":"","loc":"proc/lsi.html"},{"title":"ldp – slsqp","text":"private subroutine ldp(g, mg, m, n, h, x, xnorm, w, mode) Least distance programming routine.\n  Minimize subject to . The declared dimension of w must be at least (n+1)*(m+2)+2*m : first ( n + 1 ) * m locs of w = matrix e for problem nnls . next n + 1 locs of w = vector f for problem nnls . next n + 1 locs of w = vector z for problem nnls . next m locs of w = vector y for problem nnls . next m locs of w = vector wdual for problem nnls . References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Note The 1995 version of this routine may have some sort of problem.\n      Using a refactored version of the original routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(mg,n) :: g on entry g stores the m by n matrix of\n linear inequality constraints. g has first\n dimensioning parameter mg integer, intent(in) :: mg integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in), dimension(m) :: h the right side of the inequality system. real(kind=wp), intent(out), dimension(n) :: x solution vector x if mode=1 . real(kind=wp), intent(out) :: xnorm euclidian norm of the solution vector\n if computation is successful real(kind=wp), intent(inout), dimension(*) :: w w is a one dimensional working space, the length\n of which should be at least (m+2)*(n+1) + 2*m .\n on exit w stores the lagrange multipliers\n associated with the constraints.\n at the solution of problem ldp . integer, intent(out) :: mode success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<=0 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible. Calls proc~~ldp~~CallsGraph proc~ldp ldp proc~dcopy dcopy proc~ldp->proc~dcopy proc~daxpy daxpy proc~ldp->proc~daxpy proc~diff diff proc~ldp->proc~diff proc~ddot ddot proc~ldp->proc~ddot proc~dnrm2 dnrm2 proc~ldp->proc~dnrm2 proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 proc~h12 h12 proc~nnls->proc~h12 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ldp~~CalledByGraph proc~ldp ldp proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ldp Source Code subroutine ldp ( g , mg , m , n , h , x , xnorm , w , mode ) implicit none integer , intent ( in ) :: mg integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), dimension ( mg , n ), intent ( in ) :: g !! on entry `g` stores the `m` by `n` matrix of !! linear inequality constraints. `g` has first !! dimensioning parameter `mg` real ( wp ), dimension ( m ), intent ( in ) :: h !! the right side of the inequality system. real ( wp ), dimension ( n ), intent ( out ) :: x !! solution vector `x` if `mode=1`. real ( wp ), dimension ( * ), intent ( inout ) :: w !! `w` is a one dimensional working space, the length !! of which should be at least `(m+2)*(n+1) + 2*m`. !! on exit `w` stores the lagrange multipliers !! associated with the constraints. !! at the solution of problem `ldp`. real ( wp ), intent ( out ) :: xnorm !! euclidian norm of the solution vector !! if computation is successful integer , intent ( out ) :: mode !! success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<=0`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible. integer :: i , iw , iwdual , iy , iz , j , jf , n1 real ( wp ) :: fac , rnorm if ( n <= 0 ) then ! error return. mode = 2 else ! state dual problem mode = 1 x = zero xnorm = zero if ( m /= 0 ) then iw = 0 do j = 1 , m do i = 1 , n iw = iw + 1 w ( iw ) = g ( j , i ) end do iw = iw + 1 w ( iw ) = h ( j ) end do jf = iw + 1 do i = 1 , n iw = iw + 1 w ( iw ) = zero end do w ( iw + 1 ) = one n1 = n + 1 iz = iw + 2 iy = iz + n1 iwdual = iy + m ! solve dual problem call nnls ( w , n1 , n1 , m , w ( jf ), w ( iy ), rnorm , w ( iwdual ), w ( iz ), mode ) if ( mode == 1 ) then mode = 4 if ( rnorm > zero ) then !  compute solution of primal problem fac = one - ddot ( m , h , 1 , w ( iy ), 1 ) if ( diff ( one + fac , one ) > zero ) then mode = 1 fac = one / fac do j = 1 , n x ( j ) = fac * ddot ( m , g ( 1 , j ), 1 , w ( iy ), 1 ) end do xnorm = dnrm2 ( n , x , 1 ) ! compute lagrange multipliers for primal problem w ( 1 ) = zero call dcopy ( m , w ( 1 ), 0 , w , 1 ) call daxpy ( m , fac , w ( iy ), 1 , w , 1 ) end if end if end if end if end if end subroutine ldp","tags":"","loc":"proc/ldp.html"},{"title":"nnls – slsqp","text":"private subroutine nnls(a, mda, m, n, b, x, rnorm, w, zz, mode) Nonnegative least squares algorithm. Given an m by n matrix, , and an m-vector, ,\n  compute an n-vector, , that solves the least squares problem: subject to References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a on entry, contains the m by n matrix, a . on exit, contains\n the product matrix, q*a , where q is an m by m orthogonal matrix generated implicitly by\n this subroutine. integer, intent(in) :: mda first dimensioning parameter for the array a . integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(m) :: b on entry, contains the m-vector b . on exit, contains q*b . real(kind=wp), intent(out), dimension(n) :: x the solution vector. real(kind=wp), intent(out) :: rnorm euclidean norm of the residual vector. real(kind=wp), intent(inout), dimension(n) :: w array of working space.  on exit w will contain\n the dual solution vector. w will satisfy w(i) = 0 for all i in set p and w(i) <= 0 for all i in set z . real(kind=wp), intent(inout), dimension(m) :: zz an m-array of working space. integer, intent(out) :: mode this is a success-failure flag with the following meanings: 1 the solution has been computed successfully. 2 the dimensions of the problem are bad. either m<=0 or n<=0 . 3 iteration count exceeded. more than 3*n iterations. Calls proc~~nnls~~CallsGraph proc~nnls nnls proc~g1 g1 proc~nnls->proc~g1 proc~diff diff proc~nnls->proc~diff proc~h12 h12 proc~nnls->proc~h12 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~nnls~~CalledByGraph proc~nnls nnls proc~ldp ldp proc~ldp->proc~nnls proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code nnls Source Code subroutine nnls ( a , mda , m , n , b , x , rnorm , w , zz , mode ) implicit none integer , intent ( in ) :: mda !! first dimensioning parameter for the array `a`. integer , intent ( in ) :: n real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! on entry, contains the `m` by `n` !! matrix, `a`. on exit, contains !! the product matrix, `q*a`, where `q` is an !! `m` by `m` orthogonal matrix generated implicitly by !! this subroutine. integer , intent ( in ) :: m real ( wp ), dimension ( m ), intent ( inout ) :: b !! on entry, contains the m-vector `b`. on exit, contains `q*b`. real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution vector. real ( wp ), intent ( out ) :: rnorm !! euclidean norm of the residual vector. real ( wp ), dimension ( n ), intent ( inout ) :: w !! array of working space.  on exit `w` will contain !! the dual solution vector. `w` will satisfy `w(i) = 0` !! for all `i` in set `p` and `w(i) <= 0` for all `i` in set `z`. real ( wp ), dimension ( m ), intent ( inout ) :: zz !! an m-array of working space. integer , intent ( out ) :: mode !! this is a success-failure flag with the following meanings: !! !! * ***1*** the solution has been computed successfully. !! * ***2*** the dimensions of the problem are bad. either `m<=0` or `n<=0`. !! * ***3*** iteration count exceeded. more than `3*n` iterations. integer :: i , ii , ip , iter , itmax , iz , iz1 , iz2 , izmax , j , jj , jz , l , npp1 , nsetp , rtnkey real ( wp ) :: alpha , asave , cc , sm , ss , t , temp , unorm , up , wmax , ztest real ( wp ), dimension ( 1 ) :: dummy integer , dimension ( n ) :: index !! an integer working array. !! the contents of this array define the sets !! `p` and `z` as follows: !! !! * `index(1:nsetp) = set p`. !! * `index(iz1:iz2) = set z`. !! !! where: `iz1 = nsetp + 1 = npp1`, `iz2 = n` real ( wp ), parameter :: factor = 0.01_wp mode = 1 if ( m <= 0 . or . n <= 0 ) then mode = 2 return end if iter = 0 itmax = 3 * n ! initialize the arrays index(1:n) and x(1:n). x = zero index = [( i , i = 1 , n )] iz2 = n iz1 = 1 nsetp = 0 npp1 = 1 ! ******  main loop begins here  ****** ! quit if all coefficients are already in the solution. ! or if m cols of a have been triangularized. 100 if ( iz1 <= iz2 . and . nsetp < m ) then ! compute components of the dual (negative gradient) vector w(). do iz = iz1 , iz2 j = index ( iz ) sm = zero do l = npp1 , m sm = sm + a ( l , j ) * b ( l ) end do w ( j ) = sm end do ! find largest positive w(j). 150 wmax = zero do iz = iz1 , iz2 j = index ( iz ) if ( w ( j ) > wmax ) then wmax = w ( j ) izmax = iz end if end do ! if wmax <= 0. go to termination. ! this indicates satisfaction of the kuhn-tucker conditions. if ( wmax > zero ) then iz = izmax j = index ( iz ) ! the sign of w(j) is ok for j to be moved to set p. ! begin the transformation and check new diagonal element to avoid ! near linear dependence. asave = a ( npp1 , j ) call h12 ( 1 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , dummy , 1 , 1 , 0 ) unorm = zero if ( nsetp /= 0 ) then do l = 1 , nsetp unorm = unorm + a ( l , j ) ** 2 end do end if unorm = sqrt ( unorm ) if ( diff ( unorm + abs ( a ( npp1 , j )) * factor , unorm ) > zero ) then ! col j is sufficiently independent.  copy b into zz, update zz ! and solve for ztest ( = proposed new value for x(j) ). do l = 1 , m zz ( l ) = b ( l ) end do call h12 ( 2 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , zz , 1 , 1 , 1 ) ztest = zz ( npp1 ) / a ( npp1 , j ) ! see if ztest is positive if ( ztest > zero ) then ! the index j=index(iz) has been selected to be moved from ! set z to set p. update b, update indices, apply householder ! transformations to cols in new set z, zero subdiagonal elts in ! col j, set w(j)=0. do l = 1 , m b ( l ) = zz ( l ) end do index ( iz ) = index ( iz1 ) index ( iz1 ) = j iz1 = iz1 + 1 nsetp = npp1 npp1 = npp1 + 1 if ( iz1 <= iz2 ) then do jz = iz1 , iz2 jj = index ( jz ) call h12 ( 2 , nsetp , npp1 , m , a ( 1 , j ), 1 , up , a ( 1 , jj ), 1 , mda , 1 ) end do end if if ( nsetp /= m ) then do l = npp1 , m a ( l , j ) = zero end do end if w ( j ) = zero ! solve the triangular system. ! store the solution temporarily in zz(). rtnkey = 1 goto 300 end if end if ! reject j as a candidate to be moved from set z to set p. ! restore a(npp1,j), set w(j)=0., and loop back to test dual ! coeffs again. a ( npp1 , j ) = asave w ( j ) = zero goto 150 end if end if ! ******  end of main loop  ****** ! come to here for termination. ! compute the norm of the final residual vector. 200 sm = zero if ( npp1 <= m ) then do i = npp1 , m sm = sm + b ( i ) ** 2 end do else do j = 1 , n w ( j ) = zero end do end if rnorm = sqrt ( sm ) return ! the following block of code is used as an internal subroutine ! to solve the triangular system, putting the solution in zz(). 300 do l = 1 , nsetp ip = nsetp + 1 - l if ( l /= 1 ) then do ii = 1 , ip zz ( ii ) = zz ( ii ) - a ( ii , jj ) * zz ( ip + 1 ) end do end if jj = index ( ip ) zz ( ip ) = zz ( ip ) / a ( ip , jj ) end do if ( rtnkey /= 1 . and . rtnkey /= 2 ) return ! ******  secondary loop begins here ****** ! iteration counter. iter = iter + 1 if ( iter > itmax ) then mode = 3 !write (*,'(/a)') ' nnls quitting on iteration count.' goto 200 end if ! see if all new constrained coeffs are feasible. ! if not compute alpha. alpha = two do ip = 1 , nsetp l = index ( ip ) if ( zz ( ip ) <= zero ) then t = - x ( l ) / ( zz ( ip ) - x ( l )) if ( alpha > t ) then alpha = t jj = ip end if end if end do ! if all new constrained coeffs are feasible then alpha will ! still = 2.    if so exit from secondary loop to main loop. if ( abs ( alpha - two ) <= zero ) then ! ******  end of secondary loop  ****** do ip = 1 , nsetp i = index ( ip ) x ( i ) = zz ( ip ) end do ! all new coeffs are positive.  loop back to beginning. goto 100 else ! otherwise use alpha which will be between 0. and 1. to ! interpolate between the old x and the new zz. do ip = 1 , nsetp l = index ( ip ) x ( l ) = x ( l ) + alpha * ( zz ( ip ) - x ( l )) end do ! modify a and b and the index arrays to move coefficient i ! from set p to set z. i = index ( jj ) 350 x ( i ) = zero if ( jj /= nsetp ) then jj = jj + 1 do j = jj , nsetp ii = index ( j ) index ( j - 1 ) = ii call g1 ( a ( j - 1 , ii ), a ( j , ii ), cc , ss , a ( j - 1 , ii )) a ( j , ii ) = zero do l = 1 , n if ( l /= ii ) then ! apply procedure g2 (cc,ss,a(j-1,l),a(j,l)) temp = a ( j - 1 , l ) a ( j - 1 , l ) = cc * temp + ss * a ( j , l ) a ( j , l ) = - ss * temp + cc * a ( j , l ) end if end do ! apply procedure g2 (cc,ss,b(j-1),b(j)) temp = b ( j - 1 ) b ( j - 1 ) = cc * temp + ss * b ( j ) b ( j ) = - ss * temp + cc * b ( j ) end do end if npp1 = nsetp nsetp = nsetp - 1 iz1 = iz1 - 1 index ( iz1 ) = i ! see if the remaining coeffs in set p are feasible.  they should ! be because of the way alpha was determined. ! if any are infeasible it is due to round-off error.  any ! that are nonpositive will be set to zero ! and moved from set p to set z. do jj = 1 , nsetp i = index ( jj ) if ( x ( i ) <= zero ) goto 350 end do ! copy b( ) into zz( ).  then solve again and loop back. do i = 1 , m zz ( i ) = b ( i ) end do rtnkey = 2 goto 300 end if end subroutine nnls","tags":"","loc":"proc/nnls.html"},{"title":"hfti – slsqp","text":"private subroutine hfti(a, mda, m, n, b, mdb, nb, tau, krank, rnorm, h, g) Rank-deficient least squares algorithm using\n  householder forward triangulation with column interchanges. References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a the array a initially contains the matrix of the least squares problem .\n either m >= n or m < n is permitted.\n there is no restriction on the rank of a .\n the matrix a will be modified by the subroutine. integer, intent(in) :: mda the first dimensioning parameter of matrix a (mda >= m). integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(mdb,nb) :: b if nb = 0 the subroutine will make no reference\n to the array b . if nb > 0 the array b must\n initially contain the m x nb matrix b of the\n the least squares problem ax = b and on return\n the array b will contain the n x nb solution x . integer, intent(in) :: mdb first dimensioning parameter of matrix b (mdb>=max(m,n)) integer, intent(in) :: nb real(kind=wp), intent(in) :: tau absolute tolerance parameter for pseudorank\n determination, provided by the user. integer, intent(out) :: krank pseudorank of a , set by the subroutine. real(kind=wp), intent(out), dimension(nb) :: rnorm on exit, rnorm(j) will contain the euclidian\n norm of the residual vector for the problem\n defined by the j-th column vector of the array b . real(kind=wp), intent(inout), dimension(n) :: h array of working space real(kind=wp), intent(inout), dimension(n) :: g array of working space Calls proc~~hfti~~CallsGraph proc~hfti hfti proc~diff diff proc~hfti->proc~diff proc~h12 h12 proc~hfti->proc~h12 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~hfti~~CalledByGraph proc~hfti hfti proc~lsei lsei proc~lsei->proc~hfti proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code hfti Source Code subroutine hfti ( a , mda , m , n , b , mdb , nb , tau , krank , rnorm , h , g ) implicit none integer , intent ( in ) :: mda !! the first dimensioning parameter of matrix `a` (mda >= m). integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: mdb !! first dimensioning parameter of matrix `b` (mdb>=max(m,n)) integer , intent ( in ) :: nb real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! the array `a` initially contains the  m \\times n  matrix \\mathbf{A} !! of the least squares problem  \\mathbf{A} \\mathbf{x} = \\mathbf{b} . !! either `m >= n` or `m < n` is permitted. !! there is no restriction on the rank of `a`. !! the matrix `a` will be modified by the subroutine. real ( wp ), intent ( in ) :: tau !! absolute tolerance parameter for pseudorank !! determination, provided by the user. integer , intent ( out ) :: krank !! pseudorank of `a`, set by the subroutine. real ( wp ), dimension ( nb ), intent ( out ) :: rnorm !! on exit, `rnorm(j)` will contain the euclidian !! norm of the residual vector for the problem !! defined by the `j-th` column vector of the array `b`. real ( wp ), dimension ( n ), intent ( inout ) :: h !! array of working space real ( wp ), dimension ( n ), intent ( inout ) :: g !! array of working space real ( wp ), dimension ( mdb , nb ), intent ( inout ) :: b !! if `nb = 0` the subroutine will make no reference !! to the array `b`. if `nb > 0` the array `b` must !! initially contain the `m x nb` matrix `b` of the !! the least squares problem `ax = b` and on return !! the array `b` will contain the `n x nb` solution `x`. integer :: i , ii , ip1 , j , jb , jj , k , kp1 , l , ldiag , lmax real ( wp ) :: hmax , sm , tmp logical :: need_lmax integer , dimension ( n ) :: ip !! integer array of working space !! recording permutation indices of column vectors real ( wp ), parameter :: factor = 0.001_wp k = 0 ldiag = min ( m , n ) if ( ldiag <= 0 ) then ! the solution vectors, x, are now ! in the first  n  rows of the array b(,). krank = k return else do j = 1 , ldiag need_lmax = . true . if ( j /= 1 ) then ! update squared column lengths and find lmax lmax = j do l = j , n h ( l ) = h ( l ) - a ( j - 1 , l ) ** 2 if ( h ( l ) > h ( lmax ) ) lmax = l end do if ( diff ( hmax + factor * h ( lmax ), hmax ) > zero ) need_lmax = . false . end if if ( need_lmax ) then ! compute squared column lengths and find lmax lmax = j do l = j , n h ( l ) = zero do i = j , m h ( l ) = h ( l ) + a ( i , l ) ** 2 end do if ( h ( l ) > h ( lmax ) ) lmax = l end do hmax = h ( lmax ) end if ! lmax has been determined ! do column interchanges if needed. ip ( j ) = lmax if ( ip ( j ) /= j ) then do i = 1 , m tmp = a ( i , j ) a ( i , j ) = a ( i , lmax ) a ( i , lmax ) = tmp end do h ( lmax ) = h ( j ) end if ! compute the j-th transformation and apply it to a and b. call h12 ( 1 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), a ( 1 , j + 1 ), 1 , mda , n - j ) call h12 ( 2 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), b , 1 , mdb , nb ) end do ! determine the pseudorank, k, using the tolerance, tau. do j = 1 , ldiag if ( abs ( a ( j , j )) <= tau ) exit end do k = j - 1 kp1 = j end if ! compute the norms of the residual vectors. if ( nb > 0 ) then do jb = 1 , nb tmp = zero if ( kp1 <= m ) then do i = kp1 , m tmp = tmp + b ( i , jb ) ** 2 end do end if rnorm ( jb ) = sqrt ( tmp ) end do end if ! special for pseudorank = 0 if ( k > 0 ) then ! if the pseudorank is less than n compute householder ! decomposition of first k rows. if ( k /= n ) then do ii = 1 , k i = kp1 - ii call h12 ( 1 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), a , mda , 1 , i - 1 ) end do end if if ( nb > 0 ) then do jb = 1 , nb ! solve the k by k triangular system. do l = 1 , k sm = zero i = kp1 - l if ( i /= k ) then ip1 = i + 1 do j = ip1 , k sm = sm + a ( i , j ) * b ( j , jb ) end do end if b ( i , jb ) = ( b ( i , jb ) - sm ) / a ( i , i ) end do ! complete computation of solution vector. if ( k /= n ) then do j = kp1 , n b ( j , jb ) = zero end do do i = 1 , k call h12 ( 2 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), b ( 1 , jb ), 1 , mdb , 1 ) end do end if ! re-order the solution vector to compensate for the ! column interchanges. do jj = 1 , ldiag j = ldiag + 1 - jj if ( ip ( j ) /= j ) then l = ip ( j ) tmp = b ( l , jb ) b ( l , jb ) = b ( j , jb ) b ( j , jb ) = tmp end if end do end do end if else if ( nb > 0 ) then do jb = 1 , nb do i = 1 , n b ( i , jb ) = zero end do end do end if krank = k end subroutine hfti","tags":"","loc":"proc/hfti.html"},{"title":"h12 – slsqp","text":"private subroutine h12(mode, lpivot, l1, m, u, iue, up, c, ice, icv, ncv) Construction and/or application of a single\n  householder transformation . References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode 1 or 2 -- selects algorithm h1 to construct and apply a\n householder transformation, or algorithm h2 to apply a\n previously constructed transformation. integer, intent(in) :: lpivot the index of the pivot element integer, intent(in) :: l1 if l1 <= m the transformation will be constructed to\n zero elements indexed from l1 through m .\n if l1 > m the subroutine does an identity transformation. integer, intent(in) :: m see li . real(kind=wp), intent(inout), dimension(iue,*) :: u on entry with mode = 1 , u contains the pivot\n vector. iue is the storage increment between elements.\n on exit when mode = 1 , u and up contain quantities\n defining the vector u of the householder transformation.\n on entry with mode = 2 , u and up should contain\n quantities previously computed with mode = 1 .  these will\n not be modified during the entry with mode = 2 . dimension[u(iue,m)] integer, intent(in) :: iue see u . real(kind=wp), intent(inout) :: up see u . real(kind=wp), intent(inout), dimension(*) :: c on entry with mode = 1 or 2 , c contains a matrix which\n will be regarded as a set of vectors to which the\n householder transformation is to be applied.\n on exit c contains the set of transformed vectors. integer, intent(in) :: ice storage increment between elements of vectors in c . integer, intent(in) :: icv storage increment between vectors in c . integer, intent(in) :: ncv number of vectors in c to be transformed. if ncv <= 0 no operations will be done on c . Called by proc~~h12~~CalledByGraph proc~h12 h12 proc~lsei lsei proc~lsei->proc~h12 proc~lsi lsi proc~lsei->proc~lsi proc~hfti hfti proc~lsei->proc~hfti proc~nnls nnls proc~nnls->proc~h12 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~ldp->proc~nnls proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h12 Source Code subroutine h12 ( mode , lpivot , l1 , m , u , iue , up , c , ice , icv , ncv ) implicit none integer , intent ( in ) :: mode !! `1` or `2` -- selects algorithm ***h1*** to construct and apply a !! householder transformation, or algorithm ***h2*** to apply a !! previously constructed transformation. integer , intent ( in ) :: lpivot !! the index of the pivot element integer , intent ( in ) :: l1 !! if `l1 <= m` the transformation will be constructed to !! zero elements indexed from `l1` through `m`. !! if `l1 > m` the subroutine does an identity transformation. integer , intent ( in ) :: m !! see `li`. integer , intent ( in ) :: iue !! see `u`. real ( wp ), dimension ( iue , * ), intent ( inout ) :: u !! on entry with `mode = 1`, `u` contains the pivot !! vector.  `iue` is the storage increment between elements. !! on exit when `mode = 1`, `u` and `up` contain quantities !! defining the vector `u` of the householder transformation. !! on entry with `mode = 2`, `u` and `up` should contain !! quantities previously computed with `mode = 1`.  these will !! not be modified during the entry with `mode = 2`. !! `dimension[u(iue,m)]` real ( wp ), intent ( inout ) :: up !! see `u`. real ( wp ), dimension ( * ), intent ( inout ) :: c !! on entry with `mode = 1 or 2`, `c` contains a matrix which !! will be regarded as a set of vectors to which the !! householder transformation is to be applied. !! on exit `c` contains the set of transformed vectors. integer , intent ( in ) :: ice !! storage increment between elements of vectors in `c`. integer , intent ( in ) :: icv !! storage increment between vectors in `c`. integer , intent ( in ) :: ncv !! number of vectors in `c` to be transformed. if `ncv <= 0` !! no operations will be done on `c`. integer :: i , i2 , i3 , i4 , incr , j real ( wp ) :: b , cl , clinv , sm if ( 0 >= lpivot . or . lpivot >= l1 . or . l1 > m ) return cl = abs ( u ( 1 , lpivot )) if ( mode /= 2 ) then ! construct the transformation. do j = l1 , m cl = max ( abs ( u ( 1 , j )), cl ) end do if ( cl <= zero ) return clinv = one / cl sm = ( u ( 1 , lpivot ) * clinv ) ** 2 do j = l1 , m sm = sm + ( u ( 1 , j ) * clinv ) ** 2 end do cl = cl * sqrt ( sm ) if ( u ( 1 , lpivot ) > zero ) cl = - cl up = u ( 1 , lpivot ) - cl u ( 1 , lpivot ) = cl else if ( cl <= zero ) then return end if if ( ncv > 0 ) then ! apply the transformation i+u*(u**t)/b to c. b = up * u ( 1 , lpivot ) ! b must be nonpositive here. if ( b < zero ) then b = one / b i2 = 1 - icv + ice * ( lpivot - 1 ) incr = ice * ( l1 - lpivot ) do j = 1 , ncv i2 = i2 + icv i3 = i2 + incr i4 = i3 sm = c ( i2 ) * up do i = l1 , m sm = sm + c ( i3 ) * u ( 1 , i ) i3 = i3 + ice end do if ( abs ( sm ) > zero ) then sm = sm * b c ( i2 ) = c ( i2 ) + sm * up do i = l1 , m c ( i4 ) = c ( i4 ) + sm * u ( 1 , i ) i4 = i4 + ice end do end if end do end if end if end subroutine h12","tags":"","loc":"proc/h12.html"},{"title":"g1 – slsqp","text":"private subroutine g1(a, b, c, s, sig) Compute orthogonal rotation matrix. Compute matrix so that Compute is computed last to allow for the possibility that sig may be in the same location as a or b . References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s real(kind=wp) :: sig Called by proc~~g1~~CalledByGraph proc~g1 g1 proc~nnls nnls proc~nnls->proc~g1 proc~ldp ldp proc~ldp->proc~nnls proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code g1 Source Code subroutine g1 ( a , b , c , s , sig ) implicit none real ( wp ) :: a real ( wp ) :: b real ( wp ) :: sig real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s real ( wp ) :: xr , yr if ( abs ( a ) > abs ( b ) ) then xr = b / a yr = sqrt ( one + xr ** 2 ) c = sign ( one / yr , a ) s = c * xr sig = abs ( a ) * yr else if ( abs ( b ) > zero ) then xr = a / b yr = sqrt ( one + xr ** 2 ) s = sign ( one / yr , b ) c = s * xr sig = abs ( b ) * yr else sig = zero c = zero s = one end if end if end subroutine g1","tags":"","loc":"proc/g1.html"},{"title":"ldl – slsqp","text":"private subroutine ldl(n, a, z, sigma, w) - rank-one - update Purpose: Updates the factors of matrix by rank-one matrix . Reference R. Fletcher, M.J.D. Powell,\n    \" On the modification of LDL' factorization \".\n    Mathematics of Computation Vol. 28, No. 128, p. 1067-1087, October 1974. History D. Kraft, DFVLR - institut fuer dynamik der flugsysteme\n    d-8031  oberpfaffenhofen Status: 15. january 1980 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the coefficient matrix a real(kind=wp), intent(inout), dimension(*) :: a In: positive definite matrix of dimension n ;\n only the lower triangle is used and is stored column by\n column as one dimensional array of dimension n*(n+1)/2 . Out: updated factors real(kind=wp), intent(inout), dimension(*) :: z vector of dimension n of updating elements. real(kind=wp), intent(in) :: sigma scalar factor by which the modifying dyade is multiplied. real(kind=wp), intent(inout), dimension(*) :: w working array of dimension n (used only if ). Called by proc~~ldl~~CalledByGraph proc~ldl ldl proc~slsqpb slsqpb proc~slsqpb->proc~ldl proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ldl Source Code subroutine ldl ( n , a , z , sigma , w ) implicit none integer , intent ( in ) :: n !! order of the coefficient matrix `a` real ( wp ), intent ( in ) :: sigma !! scalar factor by which the modifying dyade z z&#94;T is multiplied. real ( wp ), dimension ( * ), intent ( inout ) :: a !! ***In:*** positive definite matrix of dimension `n`; !! only the lower triangle is used and is stored column by !! column as one dimensional array of dimension `n*(n+1)/2`. !! !! ***Out:*** updated LDL&#94;T factors real ( wp ), dimension ( * ), intent ( inout ) :: w !! working array of dimension `n` (used only if  \\sigma \\lt 0  ). real ( wp ), dimension ( * ), intent ( inout ) :: z !! vector of dimension `n` of updating elements. integer :: i , ij , j real ( wp ) :: t , v , u , tp , beta , alpha , delta , gamma if ( abs ( sigma ) > zero ) then ij = 1 t = one / sigma if ( sigma <= zero ) then ! prepare negative update do i = 1 , n w ( i ) = z ( i ) end do do i = 1 , n v = w ( i ) t = t + v * v / a ( ij ) do j = i + 1 , n ij = ij + 1 w ( j ) = w ( j ) - v * a ( ij ) end do ij = ij + 1 end do if ( t >= zero ) t = epmach / sigma do i = 1 , n j = n + 1 - i ij = ij - i u = w ( j ) w ( j ) = t t = t - u * u / a ( ij ) end do end if ! here updating begins do i = 1 , n v = z ( i ) delta = v / a ( ij ) if ( sigma < zero ) tp = w ( i ) if ( sigma > zero ) tp = t + delta * v alpha = tp / t a ( ij ) = alpha * a ( ij ) if ( i == n ) return beta = delta / tp if ( alpha > four ) then gamma = t / tp do j = i + 1 , n ij = ij + 1 u = a ( ij ) a ( ij ) = gamma * u + beta * z ( j ) z ( j ) = z ( j ) - v * u end do else do j = i + 1 , n ij = ij + 1 z ( j ) = z ( j ) - v * a ( ij ) a ( ij ) = a ( ij ) + beta * z ( j ) end do end if ij = ij + 1 t = tp end do end if end subroutine ldl","tags":"","loc":"proc/ldl.html"},{"title":"enforce_bounds – slsqp","text":"private subroutine enforce_bounds(x, xl, xu) enforce the bound constraints on x. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x optimization variable vector real(kind=wp), intent(in), dimension(:) :: xl lower bounds (must be same dimension as x ) real(kind=wp), intent(in), dimension(:) :: xu upper bounds (must be same dimension as x ) Called by proc~~enforce_bounds~~CalledByGraph proc~enforce_bounds enforce_bounds proc~slsqpb slsqpb proc~slsqpb->proc~enforce_bounds proc~lsq lsq proc~slsqpb->proc~lsq proc~lsq->proc~enforce_bounds proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code enforce_bounds Source Code subroutine enforce_bounds ( x , xl , xu ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( in ) :: xl !! lower bounds (must be same dimension as `x`) real ( wp ), dimension (:), intent ( in ) :: xu !! upper bounds (must be same dimension as `x`) where ( x < xl ) x = xl elsewhere ( x > xu ) x = xu end where end subroutine enforce_bounds","tags":"","loc":"proc/enforce_bounds.html"},{"title":"destroy_slsqpb_data – slsqp","text":"private subroutine destroy_slsqpb_data(me) Destructor for slsqpb_data type. Arguments Type Intent Optional Attributes Name class( slsqpb_data ), intent(out) :: me Contents Source Code destroy_slsqpb_data Source Code subroutine destroy_slsqpb_data ( me ) implicit none class ( slsqpb_data ), intent ( out ) :: me end subroutine destroy_slsqpb_data","tags":"","loc":"proc/destroy_slsqpb_data.html"},{"title":"destroy_linmin_data – slsqp","text":"private subroutine destroy_linmin_data(me) Destructor for linmin_data type. Arguments Type Intent Optional Attributes Name class( linmin_data ), intent(out) :: me Contents Source Code destroy_linmin_data Source Code subroutine destroy_linmin_data ( me ) implicit none class ( linmin_data ), intent ( out ) :: me end subroutine destroy_linmin_data","tags":"","loc":"proc/destroy_linmin_data.html"},{"title":"slsqp_support – slsqp","text":"Support routines for SLSQP. For example, routines from BLAS and LINPACK .\n  These have also been refactored into modern Fortran. Uses slsqp_kinds module~~slsqp_support~~UsesGraph module~slsqp_support slsqp_support module~slsqp_kinds slsqp_kinds module~slsqp_support->module~slsqp_kinds iso_fortran_env iso_fortran_env module~slsqp_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~slsqp_support~~UsedByGraph module~slsqp_support slsqp_support module~slsqp_core slsqp_core module~slsqp_core->module~slsqp_support module~slsqp_module slsqp_module module~slsqp_module->module~slsqp_support module~slsqp_module->module~slsqp_core Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables epmach zero one two four ten hun Functions ddot dnrm2 Subroutines daxpy dcopy dscal Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: epmach = epsilon(1.0_wp) real(kind=wp), public, parameter :: zero = 0.0_wp real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: two = 2.0_wp real(kind=wp), public, parameter :: four = 4.0_wp real(kind=wp), public, parameter :: ten = 10.0_wp real(kind=wp), public, parameter :: hun = 100.0_wp Functions public function ddot (n, dx, incx, dy, incy) forms the dot product of two vectors.\n  uses unrolled loops for increments equal to one. Read more… Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Return Value real(kind=wp) public function dnrm2 (n, x, incx) Function that returns the Euclidean norm of a vector . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: x integer, intent(in) :: incx Return Value real(kind=wp) Subroutines public subroutine daxpy (n, da, dx, incx, dy, incy) constant times a vector plus a vector.\n  uses unrolled loops for increments equal to one. Read more… Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy public subroutine dcopy (n, dx, incx, dy, incy) copies a vector, x, to a vector, y.\n  uses unrolled loops for increments equal to one. Read more… Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy public subroutine dscal (n, da, dx, incx) scales a vector by a constant.\n  uses unrolled loops for increment equal to one. Read more… Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx","tags":"","loc":"module/slsqp_support.html"},{"title":"slsqp_module – slsqp","text":"Module containing the object-oriented interface to the SLSQP method.\n  It is called using the slsqp_solver class, which\n  is the only public entity in this module. Uses slsqp_core slsqp_support iso_fortran_env slsqp_kinds module~~slsqp_module~~UsesGraph module~slsqp_module slsqp_module iso_fortran_env iso_fortran_env module~slsqp_module->iso_fortran_env module~slsqp_support slsqp_support module~slsqp_module->module~slsqp_support module~slsqp_core slsqp_core module~slsqp_module->module~slsqp_core module~slsqp_kinds slsqp_kinds module~slsqp_module->module~slsqp_kinds module~slsqp_support->module~slsqp_kinds module~slsqp_core->module~slsqp_support module~slsqp_core->module~slsqp_kinds module~slsqp_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces func grad iterfunc Derived Types slsqp_solver Functions mode_to_status_message Subroutines stop_iterations initialize_slsqp destroy_slsqp slsqp_wrapper report_message Abstract Interfaces abstract interface private subroutine func(me, x, f, c) for computing the function Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. abstract interface private subroutine grad(me, x, g, a) for computing the gradients Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) abstract interface private subroutine iterfunc(me, iter, x, f, c) for reporting an iteration Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(in) :: f value of the objective function real(kind=wp), intent(in), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. Derived Types type, public :: slsqp_solver The main class used to interface with the SLSQP solver. Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of optimization variables ( ) integer, private :: m = 0 number of constraints ( ) integer, private :: meq = 0 number of equality constraints ( ) integer, private :: max_iter = 0 maximum number of iterations real(kind=wp), private :: acc = zero accuracy tolerance real(kind=wp), private :: tolf = -one accuracy tolerance over f:  if then stop real(kind=wp), private :: toldf = -one accuracy tolerance over df: if then stop.\n It's different from acc in the case of positive derivative real(kind=wp), private :: toldx = -one accuracy tolerance over xf: if then stop integer, private :: gradient_mode = 0 how the gradients are computed: Read more… real(kind=wp), private :: gradient_delta = 1.0e8_wp perturbation step size to approximate gradients\n by finite differences ( gradient_mode 1-3). real(kind=wp), private :: alphamin = 0.1_wp min for line search real(kind=wp), private :: alphamax = 1.0_wp max for line search integer, private :: iprint = output_unit unit number of status printing (0 for no printing) real(kind=wp), private, dimension(:), allocatable :: xl lower bound on x real(kind=wp), private, dimension(:), allocatable :: xu upper bound on x integer, private :: l_w = 0 size of w real(kind=wp), private, dimension(:), allocatable :: w real work array procedure( func ), private, pointer :: f => null() problem function subroutine procedure( grad ), private, pointer :: g => null() gradient subroutine procedure( iterfunc ), private, pointer :: report => null() for reporting an iteration integer, private :: linesearch_mode = 1 linesearch mode: Read more… type( linmin_data ), private :: linmin data formerly within linmin .\n Only used when linesearch_mode=2 type( slsqpb_data ), private :: slsqpb data formerly within slsqpb . logical, private :: user_triggered_stop = .false. if the abort method has been called\n to stop the iterations Type-Bound Procedures procedure, public :: initialize => initialize_slsqp procedure, public :: destroy => destroy_slsqp procedure, public :: optimize => slsqp_wrapper procedure, public :: abort => stop_iterations procedure, private :: report_message for reporting messages to the user Functions private pure function mode_to_status_message (imode) result(message) Convert the slsqp mode flag to a message string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imode Return Value character(len=:),\n  allocatable Subroutines private subroutine stop_iterations (me) A method that the user can call to stop the iterations.\n  (it can be called in any of the functions).\n  SLSQP will stop at the end of the next iteration. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me private subroutine initialize_slsqp (me, n, m, meq, max_iter, acc, f, g, xl, xu, status_ok, linesearch_mode, iprint, report, alphamin, alphamax, gradient_mode, gradient_delta, tolf, toldf, toldx) initialize the slsqp_solver class.  see slsqp for more details. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: n the number of variables, integer, intent(in) :: m total number of constraints, integer, intent(in) :: meq number of equality constraints, integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: acc accuracy procedure( func ) :: f problem function procedure( grad ) :: g function to compute gradients (must be\n associated if gradient_mode=0 ) real(kind=wp), intent(in), dimension(n) :: xl lower bounds on x real(kind=wp), intent(in), dimension(n) :: xu upper bounds on x logical, intent(out) :: status_ok will be false if there were errors integer, intent(in), optional :: linesearch_mode 1 = inexact (default), 2 = exact integer, intent(in), optional :: iprint unit number of status messages (default=output_unit) procedure( iterfunc ), optional :: report user-defined procedure that will be called once per iteration real(kind=wp), intent(in), optional :: alphamin minimum alpha for linesearch [default 0.1] real(kind=wp), intent(in), optional :: alphamax maximum alpha for linesearch [default 1.0] integer, intent(in), optional :: gradient_mode how the gradients are to be computed: 0 - use the user-supplied g subroutine. [default] 1 - approximate by basic backward differences 2 - approximate by basic forward differences 3 - approximate by basic central differences real(kind=wp), intent(in), optional :: gradient_delta perturbation step size (>epsilon) to compute the approximated\n gradient by finite differences ( gradient_mode 1-3).\n note that this is an absolute step that does not respect\n the xl or xu variable bounds. real(kind=wp), intent(in), optional :: tolf stopping criterion if then stop. real(kind=wp), intent(in), optional :: toldf stopping criterion if then stop real(kind=wp), intent(in), optional :: toldx stopping criterion if then stop private subroutine destroy_slsqp (me) destructor for slsqp_solver . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(out) :: me private subroutine slsqp_wrapper (me, x, istat, iterations, status_message) main routine for calling slsqp . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x in: initial optimization variables, out: solution. integer, intent(out) :: istat status code (see mode in slsqp ). integer, intent(out), optional :: iterations number of iterations character(len=:), intent(out), optional allocatable :: status_message string status message\n corresponding to istat private subroutine report_message (me, str, ival, rval, fatal) Report a message from an slsqp_solver class. This uses the iprint variable in the class as the unit number for printing. Note: for fatal errors,\n  if no unit is specified, the error_unit is used. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(in) :: me character(len=*), intent(in) :: str the message to report. integer, intent(in), optional :: ival optional integer to print after the message. real(kind=wp), intent(in), optional :: rval optional real to print after the message. logical, intent(in), optional :: fatal if True, then the program is stopped (default=False).","tags":"","loc":"module/slsqp_module.html"},{"title":"slsqp_kinds – slsqp","text":"Numeric kind definitions. Uses iso_fortran_env module~~slsqp_kinds~~UsesGraph module~slsqp_kinds slsqp_kinds iso_fortran_env iso_fortran_env module~slsqp_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~slsqp_kinds~~UsedByGraph module~slsqp_kinds slsqp_kinds module~slsqp_support slsqp_support module~slsqp_support->module~slsqp_kinds module~slsqp_core slsqp_core module~slsqp_core->module~slsqp_kinds module~slsqp_core->module~slsqp_support module~slsqp_module slsqp_module module~slsqp_module->module~slsqp_kinds module~slsqp_module->module~slsqp_support module~slsqp_module->module~slsqp_core Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 Using \"double precision\" real kinds","tags":"","loc":"module/slsqp_kinds.html"},{"title":"slsqp_core – slsqp","text":"Core subroutines for the SLSQP optimization method.\n  These are refactoried versions of the original routines. Uses slsqp_support slsqp_kinds module~~slsqp_core~~UsesGraph module~slsqp_core slsqp_core module~slsqp_support slsqp_support module~slsqp_core->module~slsqp_support module~slsqp_kinds slsqp_kinds module~slsqp_core->module~slsqp_kinds module~slsqp_support->module~slsqp_kinds iso_fortran_env iso_fortran_env module~slsqp_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~slsqp_core~~UsedByGraph module~slsqp_core slsqp_core module~slsqp_module slsqp_module module~slsqp_module->module~slsqp_core Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types linmin_data slsqpb_data Functions check_convergence diff linmin Subroutines slsqp slsqpb lsq lsei lsi ldp nnls hfti h12 g1 ldl enforce_bounds destroy_slsqpb_data destroy_linmin_data Derived Types type, public :: linmin_data data formerly saved in linmin routine. Components Type Visibility Attributes Name Initial real(kind=wp), public :: a = zero real(kind=wp), public :: b = zero real(kind=wp), public :: d = zero real(kind=wp), public :: e = zero real(kind=wp), public :: p = zero real(kind=wp), public :: q = zero real(kind=wp), public :: r = zero real(kind=wp), public :: u = zero real(kind=wp), public :: v = zero real(kind=wp), public :: w = zero real(kind=wp), public :: x = zero real(kind=wp), public :: m = zero real(kind=wp), public :: fu = zero real(kind=wp), public :: fv = zero real(kind=wp), public :: fw = zero real(kind=wp), public :: fx = zero real(kind=wp), public :: tol1 = zero real(kind=wp), public :: tol2 = zero Type-Bound Procedures procedure, public :: destroy => destroy_linmin_data type, public :: slsqpb_data data formerly saved in slsqpb . Components Type Visibility Attributes Name Initial real(kind=wp), public :: t = zero real(kind=wp), public :: f0 = zero real(kind=wp), public :: h1 = zero real(kind=wp), public :: h2 = zero real(kind=wp), public :: h3 = zero real(kind=wp), public :: h4 = zero real(kind=wp), public :: t0 = zero real(kind=wp), public :: gs = zero real(kind=wp), public :: tol = zero real(kind=wp), public :: alpha = zero integer, public :: line = 0 integer, public :: iexact = 0 integer, public :: incons = 0 integer, public :: ireset = 0 integer, public :: itermx = 0 integer, public :: n1 = 0 integer, public :: n2 = 0 integer, public :: n3 = 0 Type-Bound Procedures procedure, public :: destroy => destroy_slsqpb_data Functions private function check_convergence (n, f, f0, x, x0, s, h3, acc, tolf, toldf, toldx, converged, not_converged) result(mode) Check for convergence. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: x0 real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in) :: h3 real(kind=wp), intent(in) :: acc real(kind=wp), intent(in) :: tolf real(kind=wp), intent(in) :: toldf real(kind=wp), intent(in) :: toldx integer, intent(in) :: converged mode value if converged integer, intent(in) :: not_converged mode value if not converged Return Value integer private pure elemental function diff (u, v) result(d) Replaced statement function in the original code.\n  Returns . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: u real(kind=wp), intent(in) :: v Return Value real(kind=wp) private function linmin (mode, ax, bx, f, tol, a, b, d, e, p, q, r, u, v, w, x, m, fu, fv, fw, fx, tol1, tol2) Linesearch without derivatives (used by slsqp if linesearch_mode=2 ).\n  Returns the abscissa approximating the point where f attains a minimum. Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout) :: mode controls reverse communication\n must be set to 0 initially, returns with intermediate\n values 1 and 2 which must not be changed by the user,\n ends with convergence with value 3. real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp) :: f function value at linmin which is to be brought in by\n reverse communication controlled by mode real(kind=wp), intent(in) :: tol desired length of interval of uncertainty of final result real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(inout) :: d real(kind=wp), intent(inout) :: e real(kind=wp), intent(inout) :: p real(kind=wp), intent(inout) :: q real(kind=wp), intent(inout) :: r real(kind=wp), intent(inout) :: u real(kind=wp), intent(inout) :: v real(kind=wp), intent(inout) :: w real(kind=wp), intent(inout) :: x real(kind=wp), intent(inout) :: m real(kind=wp), intent(inout) :: fu real(kind=wp), intent(inout) :: fv real(kind=wp), intent(inout) :: fw real(kind=wp), intent(inout) :: fx real(kind=wp), intent(inout) :: tol1 real(kind=wp), intent(inout) :: tol2 Return Value real(kind=wp) Subroutines public subroutine slsqp (m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, w, l_w, sdat, ldat, alphamin, alphamax, tolf, toldf, toldx) slsqp : s equential l east sq uares p rogramming\n  to solve general nonlinear optimization problems Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m is the total number of constraints, integer, intent(in) :: meq is the number of equality constraints, integer, intent(in) :: la see a , integer, intent(in) :: n is the number of variables, real(kind=wp), intent(inout), dimension(n) :: x x() stores the current iterate of the n vector x on entry x() must be initialized. on exit x() stores the solution vector x if mode = 0 . real(kind=wp), intent(in), dimension(n) :: xl xl() stores an n vector of lower bounds xl to x . real(kind=wp), intent(in), dimension(n) :: xu xu() stores an n vector of upper bounds xu to x . real(kind=wp), intent(in) :: f is the value of the objective function. real(kind=wp), intent(in), dimension(la) :: c c() stores the m vector c of constraints,\n equality constraints (if any) first.\n dimension of c must be greater or equal la ,\n which must be greater or equal max(1,m) . real(kind=wp), intent(in), dimension(n+1) :: g g() stores the n vector g of partials of the\n objective function; dimension of g must be\n greater or equal n+1 . real(kind=wp), intent(in), dimension(la,n+1) :: a the la by n + 1 array a() stores\n the m by n matrix a of constraint normals. a() has first dimensioning parameter la ,\n which must be greater or equal max(1,m) . real(kind=wp), intent(inout) :: acc abs(acc) controls the final accuracy.\n if acc < zero an exact linesearch is performed,\n otherwise an armijo-type linesearch is used. integer, intent(inout) :: iter prescribes the maximum number of iterations.\n on exit iter indicates the number of iterations. integer, intent(inout) :: mode mode controls calculation: reverse communication is used in the sense that\n the program is initialized by mode = 0 ; then it is\n to be called repeatedly by the user until a return\n with mode /= abs(1) takes place.\n if mode = -1 gradients have to be calculated,\n while with mode = 1 functions have to be calculated.\n mode must not be changed between subsequent calls of slsqp . evaluation modes : -1 : gradient evaluation, ( g & a ) 0 : on entry : initialization, ( f , g , c , a ), on exit : required accuracy for solution obtained 1 : function evaluation, ( f & c ) failure modes : 2 : number of equality constraints larger than n 3 : more than 3*n iterations in lsq subproblem 4 : inequality constraints incompatible 5 : singular matrix e in lsq subproblem 6 : singular matrix c in lsq subproblem 7 : rank-deficient equality constraint subproblem hfti 8 : positive directional derivative for linesearch 9 : more than iter iterations in sqp >=10 : working space w too small, w should be enlarged to l_w=mode/1000 , real(kind=wp), intent(inout), dimension(l_w) :: w w() is a one dimensional working space.\n the first m+n+n*n1/2 elements of w must not be\n changed between subsequent calls of slsqp .\n on return w(1) ... w(m) contain the multipliers\n associated with the general constraints, while w(m+1) ... w(m+n(n+1)/2) store the cholesky factor l*d*l(t) of the approximate hessian of the\n lagrangian columnwise dense as lower triangular\n unit matrix l with d in its 'diagonal' and w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n) contain the multipliers associated with all\n constraints of the quadratic program finding\n the search direction to the solution x* integer, intent(in) :: l_w the length of w , which should be at least: (3*n1+m)*(n1+1) for lsq +(n1-meq+1)*(mineq+2) + 2*mineq for lsi +(n1+mineq)*(n1-meq) + 2*meq + n1 for lsei + n1*n/2 + 2*m + 3*n + 3*n1 + 1 for slsqpb with mineq = m - meq + 2*n1 & n1 = n+1 type( slsqpb_data ), intent(inout) :: sdat data for slsqpb . type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min for line search real(kind=wp), intent(in) :: alphamax max for line search real(kind=wp), intent(in) :: tolf stopping criterion if then stop. real(kind=wp), intent(in) :: toldf stopping criterion if then stop. real(kind=wp), intent(in) :: toldx stopping criterion if then stop. private subroutine slsqpb (m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, r, l, x0, mu, s, u, v, w, t, f0, h1, h2, h3, h4, n1, n2, n3, t0, gs, tol, line, alpha, iexact, incons, ireset, itermx, ldat, alphamin, alphamax, tolf, toldf, toldx) nonlinear programming by solving sequentially quadratic programs Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: la integer, intent(in) :: n real(kind=wp), dimension(n) :: x real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp) :: f real(kind=wp), dimension(la) :: c real(kind=wp), dimension(n+1) :: g real(kind=wp), dimension(la,n+1) :: a real(kind=wp) :: acc integer, intent(inout) :: iter in: maximum number of iterations. out: actual number of iterations. integer, intent(inout) :: mode real(kind=wp), dimension(m+n+n+2) :: r real(kind=wp), dimension((n+1)*(n+2)/2) :: l real(kind=wp), dimension(n) :: x0 real(kind=wp), dimension(la) :: mu real(kind=wp), dimension(n+1) :: s real(kind=wp), dimension(n+1) :: u real(kind=wp), dimension(n+1) :: v real(kind=wp), intent(inout), dimension(*) :: w dim(w) = n1*(n1+1) + meq*(n1+1) + mineq*(n1+1) for lsq +(n1-meq+1)*(mineq+2) + 2*mineq for lsi +(n1+mineq)*(n1-meq) + 2*meq + n1 for lsei with mineq = m - meq + 2*n1 & n1 = n+1 real(kind=wp), intent(inout) :: t real(kind=wp), intent(inout) :: f0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(inout) :: h2 real(kind=wp), intent(inout) :: h3 real(kind=wp), intent(inout) :: h4 integer, intent(inout) :: n1 integer, intent(inout) :: n2 integer, intent(inout) :: n3 real(kind=wp), intent(inout) :: t0 real(kind=wp), intent(inout) :: gs real(kind=wp), intent(inout) :: tol integer, intent(inout) :: line real(kind=wp), intent(inout) :: alpha integer, intent(inout) :: iexact integer, intent(inout) :: incons integer, intent(inout) :: ireset integer, intent(inout) :: itermx type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min for line search real(kind=wp), intent(in) :: alphamax max for line search real(kind=wp), intent(in) :: tolf stopping criterion if then stop. real(kind=wp), intent(in) :: toldf stopping criterion if then stop real(kind=wp), intent(in) :: toldx stopping criterion if then stop private subroutine lsq (m, meq, n, nl, la, l, g, a, b, xl, xu, x, y, w, mode) Minimize with respect to ,\n  with upper triangular matrix ,\n  and vector ,\n  where the unit lower tridiangular matrix is stored columnwise\n  dense in the array with vector stored in its\n  'diagonal' thus substituting the one-elements of Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: n integer, intent(in) :: nl integer, intent(in) :: la real(kind=wp), dimension(nl) :: l real(kind=wp), dimension(n) :: g real(kind=wp), dimension(la,n) :: a real(kind=wp), dimension(la) :: b real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp), dimension(n) :: x stores the n-dimensional solution vector real(kind=wp), dimension(m+n+n) :: y stores the vector of lagrange multipliers of dimension\n m+n+n (constraints+lower+upper bounds) real(kind=wp), dimension(*) :: w integer :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank, 6: matrix c is not of full rank, 7: rank defect in hfti private subroutine lsei (c, d, e, f, g, h, lc, mc, le, me, lg, mg, n, x, xnrm, w, mode) for mode=1 , the subroutine returns the solution x of\n  equality & inequality constrained least squares problem lsei : Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(lc,n) :: c real(kind=wp), intent(inout), dimension(lc) :: d real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: lc integer, intent(in) :: mc integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnrm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w on return, stores the vector of lagrange multipliers\n in its first mc+mg elements integer, intent(out) :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank, 6: matrix c is not of full rank, 7: rank defect in hfti private subroutine lsi (e, f, g, h, le, me, lg, mg, n, x, xnorm, w, mode) for mode=1 , the subroutine returns the solution x of\n  inequality constrained linear least squares problem: Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnorm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w stores the vector of lagrange multipliers in its first mg elements integer, intent(out) :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank. private subroutine ldp (g, mg, m, n, h, x, xnorm, w, mode) Least distance programming routine.\n  Minimize subject to . Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(mg,n) :: g on entry g stores the m by n matrix of\n linear inequality constraints. g has first\n dimensioning parameter mg integer, intent(in) :: mg integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in), dimension(m) :: h the right side of the inequality system. real(kind=wp), intent(out), dimension(n) :: x solution vector x if mode=1 . real(kind=wp), intent(out) :: xnorm euclidian norm of the solution vector\n if computation is successful real(kind=wp), intent(inout), dimension(*) :: w w is a one dimensional working space, the length\n of which should be at least (m+2)*(n+1) + 2*m .\n on exit w stores the lagrange multipliers\n associated with the constraints.\n at the solution of problem ldp . integer, intent(out) :: mode success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<=0 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible. private subroutine nnls (a, mda, m, n, b, x, rnorm, w, zz, mode) Nonnegative least squares algorithm. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a on entry, contains the m by n matrix, a . on exit, contains\n the product matrix, q*a , where q is an m by m orthogonal matrix generated implicitly by\n this subroutine. integer, intent(in) :: mda first dimensioning parameter for the array a . integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(m) :: b on entry, contains the m-vector b . on exit, contains q*b . real(kind=wp), intent(out), dimension(n) :: x the solution vector. real(kind=wp), intent(out) :: rnorm euclidean norm of the residual vector. real(kind=wp), intent(inout), dimension(n) :: w array of working space.  on exit w will contain\n the dual solution vector. w will satisfy w(i) = 0 for all i in set p and w(i) <= 0 for all i in set z . real(kind=wp), intent(inout), dimension(m) :: zz an m-array of working space. integer, intent(out) :: mode this is a success-failure flag with the following meanings: 1 the solution has been computed successfully. 2 the dimensions of the problem are bad. either m<=0 or n<=0 . 3 iteration count exceeded. more than 3*n iterations. private subroutine hfti (a, mda, m, n, b, mdb, nb, tau, krank, rnorm, h, g) Rank-deficient least squares algorithm using\n  householder forward triangulation with column interchanges. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a the array a initially contains the matrix of the least squares problem .\n either m >= n or m < n is permitted.\n there is no restriction on the rank of a .\n the matrix a will be modified by the subroutine. integer, intent(in) :: mda the first dimensioning parameter of matrix a (mda >= m). integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(mdb,nb) :: b if nb = 0 the subroutine will make no reference\n to the array b . if nb > 0 the array b must\n initially contain the m x nb matrix b of the\n the least squares problem ax = b and on return\n the array b will contain the n x nb solution x . integer, intent(in) :: mdb first dimensioning parameter of matrix b (mdb>=max(m,n)) integer, intent(in) :: nb real(kind=wp), intent(in) :: tau absolute tolerance parameter for pseudorank\n determination, provided by the user. integer, intent(out) :: krank pseudorank of a , set by the subroutine. real(kind=wp), intent(out), dimension(nb) :: rnorm on exit, rnorm(j) will contain the euclidian\n norm of the residual vector for the problem\n defined by the j-th column vector of the array b . real(kind=wp), intent(inout), dimension(n) :: h array of working space real(kind=wp), intent(inout), dimension(n) :: g array of working space private subroutine h12 (mode, lpivot, l1, m, u, iue, up, c, ice, icv, ncv) Construction and/or application of a single\n  householder transformation . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode 1 or 2 -- selects algorithm h1 to construct and apply a\n householder transformation, or algorithm h2 to apply a\n previously constructed transformation. integer, intent(in) :: lpivot the index of the pivot element integer, intent(in) :: l1 if l1 <= m the transformation will be constructed to\n zero elements indexed from l1 through m .\n if l1 > m the subroutine does an identity transformation. integer, intent(in) :: m see li . real(kind=wp), intent(inout), dimension(iue,*) :: u on entry with mode = 1 , u contains the pivot\n vector. iue is the storage increment between elements.\n on exit when mode = 1 , u and up contain quantities\n defining the vector u of the householder transformation.\n on entry with mode = 2 , u and up should contain\n quantities previously computed with mode = 1 .  these will\n not be modified during the entry with mode = 2 . dimension[u(iue,m)] integer, intent(in) :: iue see u . real(kind=wp), intent(inout) :: up see u . real(kind=wp), intent(inout), dimension(*) :: c on entry with mode = 1 or 2 , c contains a matrix which\n will be regarded as a set of vectors to which the\n householder transformation is to be applied.\n on exit c contains the set of transformed vectors. integer, intent(in) :: ice storage increment between elements of vectors in c . integer, intent(in) :: icv storage increment between vectors in c . integer, intent(in) :: ncv number of vectors in c to be transformed. if ncv <= 0 no operations will be done on c . private subroutine g1 (a, b, c, s, sig) Compute orthogonal rotation matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s real(kind=wp) :: sig private subroutine ldl (n, a, z, sigma, w) - rank-one - update Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the coefficient matrix a real(kind=wp), intent(inout), dimension(*) :: a In: positive definite matrix of dimension n ;\n only the lower triangle is used and is stored column by\n column as one dimensional array of dimension n*(n+1)/2 . Out: updated factors real(kind=wp), intent(inout), dimension(*) :: z vector of dimension n of updating elements. real(kind=wp), intent(in) :: sigma scalar factor by which the modifying dyade is multiplied. real(kind=wp), intent(inout), dimension(*) :: w working array of dimension n (used only if ). private subroutine enforce_bounds (x, xl, xu) enforce the bound constraints on x. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x optimization variable vector real(kind=wp), intent(in), dimension(:) :: xl lower bounds (must be same dimension as x ) real(kind=wp), intent(in), dimension(:) :: xu upper bounds (must be same dimension as x ) private subroutine destroy_slsqpb_data (me) Destructor for slsqpb_data type. Arguments Type Intent Optional Attributes Name class( slsqpb_data ), intent(out) :: me private subroutine destroy_linmin_data (me) Destructor for linmin_data type. Arguments Type Intent Optional Attributes Name class( linmin_data ), intent(out) :: me","tags":"","loc":"module/slsqp_core.html"}]}